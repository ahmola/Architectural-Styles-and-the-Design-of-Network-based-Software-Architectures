# Architectural-Styles-and-the-Design-of-Network-based-Software-Architectures
  
  REST의 개념을 최초로 제시한 로이 필딩의 논문에 대해서 정리한 부분입니다.

## Introduction

서론으로, 왜 REST를 제안하였는지에 대해서 설명합니다.

현대 소프트웨어 시스템은 구현이 독립적인 컴포넌트들로 이루어지고 이들이 서로 통신하는 형태로 수행되게 됩니다.

소프트웨어 아키텍처는 

- 시스템을 **어떻게** 나누는지
- 컴포넌트들이 서로를 어떻게 **식별**하는지
- 데이터를 **어떤** 방식으로 전달되는지
- 시스템 구성요소들(데이터, 커넥터, 컴포넌트)들이 어떻게 **독립적으로** 진화할지
- 형식과 비형식으로 이러한 표기법을 어떻게 **표현**할지

에 대해서 연구합니다.

좋은 아키텍처는 공허한 상태에서 우연하게 만들어지는 것이 아니라, 기능/행동/사회의 요구사항의 **맥락**안에서 이루어져야 합니다.

이러한 원칙은 본질적으로 건축 분야에서와 적용된 것 같다고 저자는 주장합니다.

"**형태는 기능을 따른다**"라는 설계 원칙은 건축학 분야에서 수 백년의 실수가 축적되어 얻어진 교훈이었지만, 소프트웨어 업계에서는 이를 자주 무시하곤 합니다.

이러한 현상을 보여주는 대표적인 예시가 바로 Design-by-Buzzword, 즉 유행하는 기술스택으로 설계하기입니다.

이 현상이 보여주는 것은, 특정 아키텍처에 무엇이 필요한지 근본적인 이해가 부족하면서 발생하는 문제라고 로이 필딩은 지적합니다.

그렇기 때문에 유행에 의해서 선택하는 것이 아니라 성능, 확장성, 사람이 사용하는 방식까지 모두 고려해야한다고 말합니다.

그러면서 로이 필딩은, 네트워크 성능 향상이나 프로토콜에 집중하는 것보다, 애플리케이션의 상호작용 방식을 바꾸는 것이 성능에 더 큰 영향을 미친다고 주장합니다.

로이 필딩은 정보 제공자(그러니까 서버)가 무질서한 확장성과 독립적인 컴포넌트 배포를 감당할 수 있어야 한다고 말합니다.

즉, 언제 어떠한 상황에서도 배포가 가능해야함을 의미합니다. 이어서 웹 환경에서도 비슷한 주장을 합니다.

웹의 아키텍처는 지연이 큰 네트워크와 다수의 Trust Boundary(신뢰 경계) 사이에서 대용량 데이터 객체를 교환할 수 있는 구조로 설계되어야 한다고 주장합니다.

- 지연이 큰 네트워크 : 네트워크가 불안정하여 응답이 느리고 패킷 손실이 발생할 수 있는 환경
- 다수의 신뢰 경계 : 통신 참여자가 서로를 완전히 신뢰하지 않는 환경, 그러니까 쉽게 말하면 서로의 보안과 권한 등이 달라서 생기는 환경
- 대용량 데이터 객체 : 말 그대로 대용량을 가진 리소스(동영상, 이미지, 긴 글 등)

이를 바탕으로 풀어서 해석하면, 웹은 완벽히 신뢰가능하고 빠른 내부 네트워크를 기준으로 하는게 아니라, 

느리고 신뢰 불가한 외부 네트워크와 대용량 데이터를 주고받을 수 있어야 한다고 뜻입니다.

  서버와 클라이언트가 같은 네트워크에 있지 않고,
  네트워크가 불안정하고,
  중간에 프록시나 게이트웨이, 방화벽 등이 여러 개 있는 환경에서도
  문제가 없도록 설계를 해야한다.

라고 정리할 수 있습니다.

이것을 왜 주장했냐면, 기존의 분산 시스템(JAVA RMI, CORBA, RPC)는 서버와 클라이언트가 빠르고 안정적인 LAN에 있다고 가정한 채로 설계를 하였습니다.

그렇기 때문에, 외부의 네트워크와 통신을 하게 되면 성능이 급격하게 떨어지는 현상이 발생하고, 중간에 방화벽이나 게이트웨이가 있다면 아예 통신 자체가 안되는 문제가 발생하곤 하였습니다.

그래서, 전 세계 어디서든 안정적으로 잘 작동하기 위해 고안해낸 **설계 원칙**입니다.

REST는

  - 무상태성(stateless)
  - 캐시가능(cacheability)
  - 계층 구조(layered system)
  - 균일한 인터페이스(uniform interface)

이런 제약 조건들을 내세워서 기존 설계의 문제점을 해결하고자 한 것입니다.


결론적으로 본 논문은 다음과 같은 기여를 한다고 합니다.

	•	소프트웨어 아키텍처를 이해하기 위한 아키텍처 스타일 기반의 프레임워크 정의,
  
	•	네트워크 기반 애플리케이션 소프트웨어의 아키텍처 스타일 분류,
	
  •	분산 하이퍼미디어 시스템을 위한 REST라는 새로운 아키텍처 스타일의 제안,
	
  •	그리고 REST를 활용한 현대 웹 아키텍처 설계 및 평가 방법 제시

## 1. Software Architecture

### 1.1 Run-time Abstraction

소프트웨어 아키텍처의 핵심은 **추상화**입니다.

**캡슐화**를 통해 시스템의 세부 사항을 감추고 속성을 더 잘 식별하고 유지하기 위함이라고 저자는 주장합니다.

시스템의 아키텍처는 여러 추상화 수준으로 구성되며, 추상화의 한 형태로 존재하게 됩니다. 또한 각 추상화 수준에서 구현된 컴포넌트들 내 아키텍처가 각각 존재할 수 있다고 말합니다.

이러한 아키텍처의 재귀적 구조는 결국 분해할 수 없는 가장 기본적인 시스템 요소까지 이르게 합니다.

소프트웨어는 여러 추상화 수준과 동작 단계들로 구성되며, [시작, 초기화, 정상 동작, 재초기화, 종료] 등의 운영 단계를 가집니다.

그러나, 단순 동작뿐만 아니라 단계 간 전이(transition)도 아키텍처 또한 기술할 수 있어야 한다고 로이 필딩은 주장합니다.

그렇다면 Structure(구조)와의 차이점은 뭘까요?

아키텍처가 런타임 동작(실행할 때)의 추상화라면, 구조는 정적 소스코드(코드 그 자체)의 구조적 속성을 말합니다.

쉽게 풀어서 설명하면, 소프트웨어 아키텍처는 결국 소스코드가 아니라 실행할 때 시스템이 실제 어떤 형태로 동작하는지를 설명하는 것입니다.

추상화는 간단히 말하면 **분해**하는 것입니다.

복잡한 시스템을 여러 단계로 나눠, 각 단계에서 어떤 역할을 하는지 표현한 것을 말합니다.

예를 들어,

  시스템 수준(사용자 인증 시스템, 실제 서비스의 동작 방식) > 컴포넌트 수준(인증 서비스, 토큰발급 서비스, 유저 정보를 관리하는 서비스 등의 모듈) > 구현 수준(클래스나 메서드와 같은 실제 코드 단위)

이렇게 각 수준에서 각 아키텍철를 가진다고 주장합니다.

운영 단계(phase)별로 아키텍처가 달라진다는 말도 쉽게 예를 들면 이해할 수 있습니다.

Spring에서 설정 파일인 application.yml파일을 읽어서 설정값을 읽고 실행한 후로, 

서버에는 이미 해당 내용이 메모리에 존재하여 설정 파일이 어떻게되든 관계 없어지는, 즉, 더 이상 아키텍처(런타임)과는 관계없는, 아키텍처의 일부가 아닌 것이 되어버립니다.

아키텍처와 구조의 차이도 쉽게 정리하면, 아키텍처는 실행 시에 어떤 동작을 하느냐에 따른 설계이고, 구조는 코드가 어떻게 작성되었느냐의 설계를 말합니다.

그러니까, 아키텍처는 소스코드와 별개로 실행 시에 어떤 상호작용을 하는지에 중점을 두었는지에 대해서 설명합니다.

구조는 소스코드가 작성된 파일에 관한 것이라고 생각하면 됩니다.

필딩은 많은 개발자들이 이러한 개념을 헷갈린다고 말합니다.

아키텍처가 강조하는 서비스 간의 관계이고, 구조는 서비스 내부 구현을 말하는 것이어서 둘이 영향을 주기는 하나 **별개의 설계 행위**라는 것이 로이 필딩이 말하는 핵심입니다.

### 1.2 Elements

아키텍처에는 세 가지 구성요소가 존재한다고 로이 필딩은 말합니다.

  - 컴포넌트 : 작업을 수행하는 단위(연산, 데이터 저장, 인증 등)
  - 커넥터 : 컴포넌트 간의 통신과 상호작용 채널(HTTP, REST API, Kafka gRPC, MQ 등등)
  - 데이터 : 송수신되는 리소스(JSON, Event 등)

로 구성됩니다.

그리고 이 과정에서, 단순히 선과 상자로만 구성된 아키텍처 다이어그램을 지양할 것을 로이 필딩은 주장합니다.

왜냐하면, 아키텍처란 런타임(실행) 환경에서 각 컴포넌트들의 **상호 작용**을 나타내는 것인데, 여기서 상호 작용을 나타내는 **데이터 흐름**이 빠져있기 때문입니다.

데이터가 어떻게 오고 가는지가 시스템의 행동을 결정하는 것, 이것이 REST를 정의하는 주된 이유입니다.

그리고 아키텍처는 Rationale(설계 근거)에 대해서는 과감하게 아키텍처에서 제외하였습니다. 왜냐하면 설계 근거가 실행환경과 아무 상관이 없다고 주장합니다.

예륻 들어, Redis 캐시 서버를 왜 썼는지에 대한 근거가 설계서에 적혀있다고, 실제로 실행할 때 이 근거를 가지고 실행되는게 아니기 때문으로 이해할 수 있습니다.

아키텍처의 핵심은 **실행 중에 데이터가 어떻게 흐르고, 어떤 제약을 갖는지**이지 문서나 설계서가 아니라는 것을 뜻합니다.

즉, 데이터를 중심으로 설계를 해야한다고 주장합니다.
  
    ❌ 나쁜 다이어그램 (Shaw식)
    
    [UserService] ---- [OrderService] ---- [DB]
  
    ✅ 좋은 다이어그램 (Fielding식)
    
    [UserService]
    
     ↑ HTTP (JSON)
    
     ↓
    
    [OrderService]
    
     ↑ JDBC (SQL Query)
     
     ↓
    
    [MySQL DB]

#### 1.2.1 Component

실질적으로 데이터를 받아서 작업을 처리하거나 직접 데이터를 생성하는 **동작의 주체**로, 인터페이스가 정의되어 있고 내부 구현을 신경쓰지 않습니다.

실제 서비스 상에서 컨테이너(또는 파드나 이것들을 포함한 개념) 단위라고 생각하시면 됩니다.

#### 1.2.2 Connector

서로 연결해주는 **통신 채널**로, 데이터를 한 컴포넌트에서 다른 컴포넌트로 전달해줍니다. 데이터를 건드리지 않습니다(내부에 그런 로직이 있을 수도 있으나 일반적인 경우에는 없음).

실제 서비스 상에서 HTTP, TCP Socket, gRPC 등의 프로토콜(또는 그것들을 포함하는 개념) 정도로 이해하시면 됩니다.

#### 1.2.3 Data

실제 송수신되는 데이터로, 커넥터를 통해 알맞은 컴포넌트로 이동되는 **상호작용의 대상**입니다. 컴포넌트 내 숨겨진 메모리 변수 등은 아키텍처 데이터라고 보지 않습니다.

실제 서비스 상에서는 JSON, Message, Event, Stream, File, Serialized Object 등으로 이해하시면 됩니다.

### 1.3 Configurations

시스템의 구조적 형태인 Topology를 나타냅니다.

앞서 언급했던 컴포넌트, 커넥터, 데이터 간의 아키텍처적 관계 구조를 뜻합니다.

구성은 여기서 상호작용하는 컴포넌트와 커넥터의 집합이라고 로이 필딩은 말합니다.
