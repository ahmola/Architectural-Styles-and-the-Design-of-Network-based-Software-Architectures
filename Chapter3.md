# 3. Network-based Architectural Styles

## 3.1 Classification Methodology

저자는 소프트웨어를 만드는 것이 **요구사항 충족**에 있지, topology나 component type을 위한 것이 아니라고 처음부터 강조합니다.

즉, 요구사항을 **맞추는**거지, 요구사항이 아키텍처 스타일에 어거지로 맞춰지면 안된다는 것입니다.

아키텍처 스타일을 분류하는 기준은 어떤 유형의 구조가 아니라(그러니까 Client-Server 구조다, Layered구조다 이런 식이 아니라는 것)

스타일이 어떤 품질(Performance, Scalability)를 창출해내는지로 나누게 된다고 합니다.

새로운 아키텍처 스타일은 기존 스타일에 제약을 추가하여 만들어지며 어떤 속성이 향상되고 또 어떤 속성이 저하되기도 한다고 주장합니다.

모든 설계는 trade-off이므로 속성은 상대적이라는 주장도 이와 일맥상통합니다.

그러므로 아키텍처 스타일을 구조로 보기보다는, 속성을 변화시키는 제약의 집합이라고 볼 것을 강조합니다.

## 3.2 Data-flow Styles

데이터를 가장 단순하고 깔끔하게 보내는 방법으로 데이터를 단계별로 흘려보내면서 처리하는 구조인 **Pipe-and-Filter**구조를 소개합니다.

필터는 데이터를 받아서 가공 후 내보내고, 파이프는 데이터가 이동하는 통로입니다.

이 방식은 단순성, 재사용성, 확장성, 벙렬처리에 유용하다는 점입니다.

그러나 파이프가 많아지면 느려질 수 있고, 한 쪽이 끝나야 다음 쪽의 턴이 온다는 점에서 실시간 상호작용에서는 성능이 떨어집니다.

여기서 발전시킨 것이 **Uniform Pipe-and-Filter**입니다.

모든 필터의 입출력을 동일한 인터페이스를 쓰는 구조입니다.

이렇게 되면, 어떤 필터라도 자유롭게 연결이 가능하게 됩니다.

이렇게 **모두 같은 방식으로 요청과 응답을 주고받는다**라는 철학이 REST의 영감을 주게 됩니다.

## 3.3 Replication Style

데이터를 여러 저장소로 분산하여 저장하는 Replication Repository는 데이터 접근성과 서비스 확장성을 향상시킨다고 말합니다.

대표적으로 CVS(원격 버전 관리 시스템) 등이 있습니다.

이렇게 저장소를 복제해두면, 체감 성능이 올라가고 latency가 줄어들며, 기본 서버가 고장이 나거나 연결이 끊겨도 작업이 계속 수행될 수 있습니다.

그러나 저장소가 여러 군데로 나뉘어져 있어서 데이터의 일관성이 떨어진다는 단점이 있습니다.

RR의 변형으로 Cache가 존재하는데, 특정 요청의 결과를 저장해두었다가 같은 요청에 대해서 저장된 결과를 재사용하는 스타일입니다.

데이터가 너무 크거나 클라이언트가 전부 접근할 필요가 없을 때 사용됩니다.

캐시는 두 가지 복제 방식이 있는데, 캐시에 없는 데이터를 요청받으면 받았을 때 복사하는 지연 복제가 있고, 요청이 오기 전에 예측해서 복제하는 적극 복제가 있습니다.

그러나 캐시도 마찬가지로 데이터 일관성이 떨어지는 문제가 발생할 수 있다.

## 3.4 Hierarchical Style

이 절에서는 다양한 계층 중심의 아키텍처 스타일에 대해서 설명합니다.

### 3.4.1 Client-Server

서버가 하나 이상의 서비스를 제공하고, 서버는 클라이언트의 request를 listen합니다.

클라이언트는 서버의 서비스를 원할 때 커넥터를 통해서 서버로 request를 보내고 서버가 받아서 알맞은 response를 보냅니다.

클라이언트는 trigger 역할을, 서버는 reactive 역할을 하게 됩니다.

서버는 반영구적 프로세스이고 여러 클라이언트에게 동시에 서비스를 제공할 수 있습니다.

이 스타일의 핵심은 **관심사 분리**라는 점입니다.

기능을 명확히 나눠 서버를 단순화하고 확장성을 향상시킵니다.

또한 독립적으로 분리되었기 때문에, 서버와 클라이언트가 인터페이스만 유지하면 각각 독립적인 발전이 가능합니다.

기본적인 client-server구조에서는 앱의 상태를 어디에 저장해두어도 상관없으며, 종종 미들웨어가 구현되어 저장되기도 합니다.

### 3.4.2 Layered-Client-Server

클라이언트-서버 구조와 조합되어 사용되며, 상하관계로 구성됩니다.

계층별로 나누기 때문에 결합도를 낮추고, 재사용성과 독립적인 발전이 가능하나 오버헤드와 지연이 증가하고 성능이 떨어진다는 단점이 있습니다.

클라이언트와 서버 사이에 중간자 계층을 추가한 형태로 구성됩니다.

Gateway나 Proxy가 이런 중간 계층의 한 종류이며, 대규모 분산 시스템에서는 이런 중간 서버가 대신 라우팅해주게 됩니다.

### 3.4.3 Client-Stateless-Server(CSS)

클라이언트-서버 구조에서 서버가 세션 상태를 저장하지 않는 제약을 추가한 스타일입니다.

즉, 서버가 클라이언트들의 정보를 저장하지 않습니다.

세션에 대한 정보는 오직 클라이언트에게만 있으며, 클라이언트가 요청 시 필요한 모든 정보를 보내고 서버는 요청에 대한 상태 정보를 일절 저장하지 않게 됩니다.

요청에 모든 정보가 담겨 가시성이 뛰어나며, 요청이 다른 요청에 영향을 주지 않아 신뢰성이 높고, 서버가 세션을 저장하지 않기 때문에 부하가 적어 확장성도 좋습니다.

그러나 매번 같은 정보를 중복으로 전송해야되므로 네트워크 부하가 증가하는 문제가 발생합니다.

### 3.4.4 Client-Cache-Stateless-Server(C$SS)

CSS에 캐시를 추가한 형태로, 캐시 서버가 응답을 저장해두었다가 같은 요청을 클라이언트가 보내면 저장된 응답을 보내는 방식입니다.

성능과 효율성이 증가하나, 오래된 데이터(stale)가 갱신되지 않으면 데이터 불일치 발생

### 3.4.5 Layered-Client-Cache-Stateless-Server(LC$SS)

LCS와 C$SS를 합친 구조로, 중간 계층 + 캐시 + 무상태 서버 구조로 구성됩니다.

대표적으로 DNS 시스템이 있습니다.

이외에도 Remote Session과 Remote Data Access가 존재하나 확장성 이슈로 잘 사용되지 않음

## 3.5 Mobile Code Style

