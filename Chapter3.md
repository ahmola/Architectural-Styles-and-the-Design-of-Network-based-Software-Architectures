# 3. Network-based Architectural Styles

## Summary

3장은 네트워크기반 아키텍처에서 흔히 볼 수 있는 스타일들에 대해서 설명합니다.

아키텍처 스타일을 평가할 때 있어서 가장 중요한 것은 속성을 개별로 분류해서 평가하는 것이 아니라 **요구사항 파악**을 통해 속성을 묶어서 해당 속성에 맞게 평가하는 것이라고 필딩은 말합니다.

그리고 필딩은 여기서 3.8.3절에서 미들웨어를 언급하면서 

  "Architecture research regarding middleware focuses on the problems and effects of integrating components with off-the-shelf middleware."

라고 언급합니다.

기존의 단순 기술 사용이 아니라, 요구사항(problem)과 아키텍처에 미치는 영향(effect)에 집중한다고 언급합니다.

즉, 무엇을 썼는지가 중요한 것이 아니라 **품질**에 신경쓰겠다는 것을 강조하는 겁니다.

## 3.1 Classification Methodology

저자는 소프트웨어를 만드는 것이 **요구사항 충족**에 있지, topology나 component type을 위한 것이 아니라고 처음부터 강조합니다.

즉, 요구사항을 **맞추는**거지, 요구사항이 아키텍처 스타일에 어거지로 맞춰지면 안된다는 것입니다.

아키텍처 스타일을 분류하는 기준은 어떤 유형의 구조가 아니라(그러니까 Client-Server 구조다, Layered구조다 이런 식이 아니라는 것)

스타일이 어떤 품질(Performance, Scalability)를 창출해내는지로 나누게 된다고 합니다.

새로운 아키텍처 스타일은 기존 스타일에 제약을 추가하여 만들어지며 어떤 속성이 향상되고 또 어떤 속성이 저하되기도 한다고 주장합니다.

모든 설계는 trade-off이므로 속성은 상대적이라는 주장도 이와 일맥상통합니다.

그러므로 아키텍처 스타일을 구조로 보기보다는, 속성을 변화시키는 제약의 집합이라고 볼 것을 강조합니다.

## 3.2 Data-flow Styles

데이터를 가장 단순하고 깔끔하게 보내는 방법으로 데이터를 단계별로 흘려보내면서 처리하는 구조인 **Pipe-and-Filter**구조를 소개합니다.

필터는 데이터를 받아서 가공 후 내보내고, 파이프는 데이터가 이동하는 통로입니다.

이 방식은 단순성, 재사용성, 확장성, 벙렬처리에 유용하다는 점입니다.

그러나 파이프가 많아지면 느려질 수 있고, 한 쪽이 끝나야 다음 쪽의 턴이 온다는 점에서 실시간 상호작용에서는 성능이 떨어집니다.

여기서 발전시킨 것이 **Uniform Pipe-and-Filter**입니다.

모든 필터의 입출력을 동일한 인터페이스를 쓰는 구조입니다.

이렇게 되면, 어떤 필터라도 자유롭게 연결이 가능하게 됩니다.

이렇게 **모두 같은 방식으로 요청과 응답을 주고받는다**라는 철학이 REST의 영감을 주게 됩니다.

## 3.3 Replication Style

데이터를 여러 저장소로 분산하여 저장하는 Replication Repository는 데이터 접근성과 서비스 확장성을 향상시킨다고 말합니다.

대표적으로 CVS(원격 버전 관리 시스템) 등이 있습니다.

이렇게 저장소를 복제해두면, 체감 성능이 올라가고 latency가 줄어들며, 기본 서버가 고장이 나거나 연결이 끊겨도 작업이 계속 수행될 수 있습니다.

그러나 저장소가 여러 군데로 나뉘어져 있어서 데이터의 일관성이 떨어진다는 단점이 있습니다.

RR의 변형으로 Cache가 존재하는데, 특정 요청의 결과를 저장해두었다가 같은 요청에 대해서 저장된 결과를 재사용하는 스타일입니다.

데이터가 너무 크거나 클라이언트가 전부 접근할 필요가 없을 때 사용됩니다.

캐시는 두 가지 복제 방식이 있는데, 캐시에 없는 데이터를 요청받으면 받았을 때 복사하는 지연 복제가 있고, 요청이 오기 전에 예측해서 복제하는 적극 복제가 있습니다.

그러나 캐시도 마찬가지로 데이터 일관성이 떨어지는 문제가 발생할 수 있다.

## 3.4 Hierarchical Style

이 절에서는 다양한 계층 중심의 아키텍처 스타일에 대해서 설명합니다.

### 3.4.1 Client-Server

서버가 하나 이상의 서비스를 제공하고, 서버는 클라이언트의 request를 listen합니다.

클라이언트는 서버의 서비스를 원할 때 커넥터를 통해서 서버로 request를 보내고 서버가 받아서 알맞은 response를 보냅니다.

클라이언트는 trigger 역할을, 서버는 reactive 역할을 하게 됩니다.

서버는 반영구적 프로세스이고 여러 클라이언트에게 동시에 서비스를 제공할 수 있습니다.

이 스타일의 핵심은 **관심사 분리**라는 점입니다.

기능을 명확히 나눠 서버를 단순화하고 확장성을 향상시킵니다.

또한 독립적으로 분리되었기 때문에, 서버와 클라이언트가 인터페이스만 유지하면 각각 독립적인 발전이 가능합니다.

기본적인 client-server구조에서는 앱의 상태를 어디에 저장해두어도 상관없으며, 종종 미들웨어가 구현되어 저장되기도 합니다.

### 3.4.2 Layered-Client-Server

클라이언트-서버 구조와 조합되어 사용되며, 상하관계로 구성됩니다.

계층별로 나누기 때문에 결합도를 낮추고, 재사용성과 독립적인 발전이 가능하나 오버헤드와 지연이 증가하고 성능이 떨어진다는 단점이 있습니다.

클라이언트와 서버 사이에 중간자 계층을 추가한 형태로 구성됩니다.

Gateway나 Proxy가 이런 중간 계층의 한 종류이며, 대규모 분산 시스템에서는 이런 중간 서버가 대신 라우팅해주게 됩니다.

### 3.4.3 Client-Stateless-Server(CSS)

클라이언트-서버 구조에서 서버가 세션 상태를 저장하지 않는 제약을 추가한 스타일입니다.

즉, 서버가 클라이언트들의 정보를 저장하지 않습니다.

세션에 대한 정보는 오직 클라이언트에게만 있으며, 클라이언트가 요청 시 필요한 모든 정보를 보내고 서버는 요청에 대한 상태 정보를 일절 저장하지 않게 됩니다.

요청에 모든 정보가 담겨 가시성이 뛰어나며, 요청이 다른 요청에 영향을 주지 않아 신뢰성이 높고, 서버가 세션을 저장하지 않기 때문에 부하가 적어 확장성도 좋습니다.

그러나 매번 같은 정보를 중복으로 전송해야되므로 네트워크 부하가 증가하는 문제가 발생합니다.

### 3.4.4 Client-Cache-Stateless-Server(C$SS)

CSS에 캐시를 추가한 형태로, 캐시 서버가 응답을 저장해두었다가 같은 요청을 클라이언트가 보내면 저장된 응답을 보내는 방식입니다.

성능과 효율성이 증가하나, 오래된 데이터(stale)가 갱신되지 않으면 데이터 불일치 발생

### 3.4.5 Layered-Client-Cache-Stateless-Server(LC$SS)

LCS와 C$SS를 합친 구조로, 중간 계층 + 캐시 + 무상태 서버 구조로 구성됩니다.

대표적으로 DNS 시스템이 있습니다.

이외에도 Remote Session과 Remote Data Access가 존재하나 확장성 이슈로 잘 사용되지 않음

## 3.5 Mobile Code Style

데이터가 아닌 코드를 옮기는 구조. 성능이 올라가고 시스템 유연성이 올라갑니다.

위치라는 개념을 도입해 코드가 실제 실행되는 곳을 뜻하며, 클라이언트가 위치에 있다면 비용이 거의 없다고 보고 위치로부터 가까울수록 성능이 올라갑니다.

  Virtual Machine: 네트워크 아키텍처 스타일은 아니나, 클라이언트-서버 구조와 결합하여 코드를 주고받아서 실행하는 엔진으로 역할을 한다(JVM, Python Interpreter). 
  코드 실행 통합 환경
  
  Remote Evaluation: 로직은 클라이언트에게 있으나 실행 리소스는 서버에 있는 스타일. 서버에서 클라이언트의 스크립트를 실행하는 구조(AWS Lambda, SQL Function). 
  서버에서 클라이언트 코드 실행
  
  Code-on-Demand: 클라이언트가 데이터를 가지고 있으나 코드가 없어 서버에게 요청하는 스타일. 서버의 부하를 줄이나 상태 예측이 힘들어 신뢰성이 낮음(브라우저 Javascript, Web Assembly). 
  클라이언트가 서버로부터 받은 코드 실행
  
  LCoDC$SS(Layered-Code-on-Demand-Client-Cache-Stateless-Server): REST아키텍처에 Code-on-Demand 제약을 추가한 형태로, LC$SS에 CoD 구조를 합침(Java Applet, Plugin).
  REST구조+ 주문형 코드
  
  Mobile Agent: 앱의 코드, 상태, 데이터가 함께 움직이는 스타일로, 프로그램이 실행 도중 서버를 옮기는 형태. REV와 CoD의 혼합형(Java Aglets, 클라우드 오케스트레이터).
  전체 프로그램이 이동하며 실행

## 3.6 Peer-to-Peer Style

클라이언트-서버 구조 없이, 서로 동등하게 통신하는 스타일입니다.

**필딩은 REST와 맞지 않아 이러한 스타일을 의도적으로 배제하였습니다.**

즉, 참고용으로만 읽어보면 됩니다.

  - Event-Based Integration: 하나의 Event Bus에 모든 컴포넌트가 연결되고 한 컴포넌트가 이벤트를 발생시켜 등록된 컴포넌트들이 시스템에 의해 자동으로 호출되도록 합니다(Pub/Sub).
    이벤트로 연결없이 통합.
    
  - C2: EBI + Layered-Client-Server 조합. 비동기 메시지가 주요 통신 방식이며, notification은 아래로, request는 위로 두어 위로 느슨합 결합과 아래로 무결합을 갖춤. 확장성 문제를 해결하기 위해 중간 계층을 둠(React 컴포넌트).
    
  - Distributed Objects: 여러 개의 동등한 객체(Peer)로 구성. 각 peer는 자신만의 상태를 가지며, 데이터를 다루는 메서드를 가져 독립된 단위로 객체가 움직인다. 서로 원격 호출이 가능(gRPC).
    객체끼리 서로 호출

  - Brokered Distributed Object: DO + Layered System 결합. 중앙 Broker가 객체 간 메시지 중개. 객체가 직접 소통하는 것이 아니라 Broker를 통해서 서로 호출(Kafka, RabbitMQ).
    객체 호출을 브로커를 통해서 중계
