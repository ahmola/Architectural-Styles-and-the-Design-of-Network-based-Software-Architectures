# 5. Network-based Architectural Styles

## 5.1 Deriving REST

웹 아키텍처는 필딩이 계속 강조하듯, **제약의 집합**을 언급합니다.

제약이 추가됨에 따라 속성이 바뀌고, 이를 통해 REST 아키텍처 스타일을 만들 수 있다고 합니다.

### 5.1.1 Null Style

건축이나 소프트웨어나 아키텍처 설계 과정에서 두 가지 관점이 존재한다고 언급합니다.

하나는 백지 상태에서 익숙한 요소들을 쌓아가며 요구사항을 만족시키는 creative build-up과,

전체 시스템을 상상하여 제약을 계속 추가하며 자연스럽게 행동을 조율하는 constraint-driven design 방식이 존재합니다.

전자는 창의성과 무한한 비전을, 후자는 절제와 문맥의 이해를 강조합니다.

REST는 후자의 방식을 택합니다.

널 스타일은 아무런 제약도 존재하지 않는 상태를 말합니다.

컴포넌트 간의 경계가 없고, 모든 요소가 하나로 묶여있으며 아무런 구조나 규칙이 없는 자유 상태입니다.

REST 이러한 "백지 상태"에서 출발하여 하나씩 더해갑니다.

### 5.1.2 Client-Server Style

클라이언트-서버 스타일은 네트워크 기반 아키텍처에서 흔히 사용되는 아키텍처 스타일로,

서버가 여러 클라이언트들에게 동일한 서비스를 제공하며, 클라이언트는 request를 통해 통신을 시작하고 서버는 요청을 listen하여 response를 반환합니다.

여기서 커넥터의 역할을 네트워크 프로토콜이 맡습니다.

핵심은 UI와 Data Storage를 분리했다는 점입니다.

클라이언트는 UI부분만을 맡고, 서버는 데이터 저장과 관리를 담당하여 데이터와 데이터를 사용하는 앱이 독립적으로 존재할 수 있게 됩니다.

인터페이스가 변하지 않는다면, 서버와 클라이언트 각각 독립적으로 진화할 수 있습니다.

UI는 이식성이 올라가고 클라이언트의 변경이 서버에 영향을 주지 않아 유지보수성도 올라가며 서버는 확장성이 증가하게되어 서버가 단순해질수록 여러 클라이언트가 동시에 동일한 서버를 사용할 수 있게 됩니다.

그러나, 네트워크 특성상 오버헤드가 발생하고 데이터 변환과 송수신 과정에서 효율성이 떨어지며 Latency가 발생합니다.

또한 가시성이 낮기 때문에, 실제 데이터 흐름의 파악이 어려워 비효율적인 네트워크 사용이 발생할 수 있습니다.

그럼에도 이러한 모든 단점을 상쇄하는 강력한 장점들로, 대부분의 분산 시스템의 기초이자 웹 아키텍처의 핵심으로 자리잡았습니다.

### 5.1.3 Stateless Style

REST 철학의 핵심인 stateless 아키텍처 스타일입니다.

클라이언트-서버 스타일을 계승하였습니다.

서버는 이전 요청이 저장된 컨텍스트를 사용하지않고 매 요청마다 해당 요청을 이해하는데 필요한 모든 정보를 자체적으로 포함하는 스타일입니다.

즉, 서버는 요청 간 상태를 기억(저장)하지 않는다는 것이 핵심입니다.

Session은 전적으로 클라이언트가 관리하고, 요청을 처리하는 동안에만 애플리케이션 상태를 임시로 저장할 뿐, 응답을 보내면 요청에 대한 정보를 모두 잊습니다.

각 요청이 독립적이므로 가시성이 향상되고, 요청의 실패가 다른 요청에게 영향을 주지 않아 신뢰성이 올라가며, 서버가 모든 클라이언트들의 상태를 저장할 필요가 없어 서버 부담이 줄어들어 확장성에도 좋습니다.

그러나, 클라이언트가 매번 똑같은 정보를 중복으로 보내야하므로 성능이 저하될 수 있고, Latency가 발생하여 체감 속도가 더 느려질 수 있습니다.

그럼에도 불구하고, 대규모 분산 시스템에서는 신뢰성과 확장성이 생명이므로 이런 문제를 감수할 가치가 있어 자주 사용됩니다.

그러면 실제로 State는 어떤 종료가 있었을까요?

필딩은 암묵적으로 Application State(사용자의 작업 단계), Resource State(서버의 리소스 상태 관리 단계)를 구분합니다(REST의 HATEOAS로 이어집니다).

필딩은 Stateless 스타일 덕분에 웹이 폭발적으로 성장할 수 있었다고 합니다.

웹 서버 입장에서는 클라이언트를 몰라도 요청의 형식만 맞으면 처리가 가능하므로, 웹의 확장성과 신뢰성에 큰 영향을 미친 설계 철학이라고 평가합니다.

### 5.1.4 Cache Style

Stateless의 경우, 매번 중복되는 데이터를 반복해서 보내야하는 치명적인 단점이 있었는데, 이걸 해결하기 위해 등장한 아키텍처 스타일이 바로 Cache입니다.

응답이 캐시 가능하다면, 클라이언트는 동일한 요청에 대해서 응답 데이터를 재사용할 권한을 갖습니다.

HTTP에서는 이러한 캐시 가능성(Cacheable)을 표시하기 위해서, Cache-Control, Expires, ETag, Last-Modified같은 헤더를 사용합니다.

즉, 서버가 캐싱 정책을 선언하고 클라이언트가 전적으로 따르는 구조입니다.

캐시 스타일을 통해, latency를 줄여 상호작용을 일부분 혹은 완전히 제거할 수 있게 됩니다.

성능 향상은 물론이고, 효율성과 확장성 또한 증가하게 됩니다.

하지만 그에 대한 trade-off(대가)로, 캐시된 데이터가 오래되어(stale), 최신 데이터의 불일치가 발생하게 되면 신뢰성이 저하될 수 있습니다.

따라서 캐시 제약을 아키텍처 스타일로 사용하게 될 경우, 만료 시간같은 응답 제어 정보를 신중히 정의해야 합니다.

캐시 제약 또한 클라이언트-서버 스타일에서 파생되었으며, stateless 스타일과 결합할 수 있습니다.

### 5.1.5 Uniform Interface

REST는 컴포넌트 간 **일관된 인터페이스**가 핵심이라고 언급합니다.

즉, 모든 컴포넌트가 같은 형식으로 대화한다는 것입니다.

각 구현체(또는 컴포넌트)는 자신의 서비스와 느슨하게 결합되어 독립적인 진화가 가능해진다는 것입니다.

그러나 표준화된 인터페이스를 요구하므로 전용 인터페이스에 비해 효율이 떨어질 수 있어서, 실시간 스트리밍이나 RPC에는 최적이 아닐 수도 있다고 강조합니다.

일관된 인터페이스를 위해서는 

  1. 리소스 식별: 고유 식별자인 URI로 식별되어야 하고
  2. 표현을 통한 리소스 조작: 리소스는 Representation(리소스의 표현 - json, mime 등)을 통해서만 조작한다.
  3. 자기 설명 메시지: 모든 메시지는 자기 자신을 설명하여 메시지만으로 요청의 의미를 파악 가능해야 한다.
  4. 하이퍼링크로 상태 전이(HATEOAS): 앱의 상태 전이는 하이퍼미디어 링크를 통해 이루어진다.

를 지켜야하며 이것의 자세한 내용은 5.2절에서 이어진다고 합니다.

### 5.1.6 Layered System Style

네트워크의 확장성과 보안, 중개, 로깅 구조 등의 유지보수성을 설명하는 부분입니다.

즉, 현대의 Proxy, Gateway, Load Balancer, CDN 등이 왜 REST에 들어가게 되었는지 나타나게 됩니다.

아키텍처가 계층적 구조로 구성되어, 각 컴포넌트들은 동작을 제약하고, 직접 상호작용하는 인접 계층 외에는 볼 수 없다는 제약이 적용됩니다.

이렇게 **지식을 제한**하여 단순성을 증가시키고, 교체가 가능하며, 진화 가능하고 설정의 자유로움을 개선할 수 있습니다.

개별 계층을 분리 가능하므로 보안이 강화되고 확장성이 향상되며, 부하 분산도 가능해지고, 레거시 시스템을 캡슐화하는 것이 가능해집니다.

그러나, 계층을 나눈다는 특성으로 인해 오버헤드와 latency가 증가하여 성능이 저하되고 중간 계층에 장애 발생 시 신뢰성이 떨어지게 됩니다.

REST는 이러한 단점에도 대규모 분산 시스템에서 Layered System이 주는 확장성과 유지보수성의 이득이 압도적이므로 사용될 수 밖에 없다고 주장합니다.

주요 중간 계층으로

  - Proxy: 요청 캐싱, 로깅, 필터링
  - Gateway: API 라우팅, 인증, 로드 밸런싱
  - CDN: 정적 리소스 캐싱
  - Load Balancer: 트래픽 분산
  - Security: 방화벽, 토큰 검증 등

이 존재하며, REST는 단순 클라이언트 - 서버 구조만을 허용하는 것이 아닌 보다 유연한 구조를 허용합니다.

### 5.1.7 Code-On-Demand

REST는 클라이언트 기능 확장을 위해 applet이나 script 형태의 코드를 서버로부터 받아 실행하는 방식으로,

클라이언트 단순화를 통한 확장성 증가를 허용하나, 가시성이 떨어지기에 선택적 제약으로만 두었다고 밝힙니다.

즉, 해당 제약은 항상 적용되는 것이 아니라 특정 환경에서 선택하여 적용 가능하다는 것을 의미합니다.

현대 웹에선 주로 Javascript가 쓰이므로 이를 예로 들어보면, 

Code-On-Demand는 웹 클라이언트가 서버에 요청하면 서버가 데이터와 Javascript코드까지 같이 주는 구조를 말합니다.

물론 이는 필딩이 처음에는 당시 웹 환경을 고려해서 정적 컨텐츠로만 한정하였기에 옵션으로 두었으나

React가 등장하면서 각종 javascript 기반 웹 클라이언트가 나오면서 사실상 필수처럼 여겨지고 있습니다.

그러나 이는 다시 필딩이 예견했던 것처럼 가시성의 문제로 이어져 API 추적이 힘들어지게 되었고, 다시 BFF(Backend-For-Frontend)가 등장하게 되는 계기가 됩니다.

## 5.2 REST Architectural Elements

REST는 내부 구현이나 프로토콜이 아니라 **웹이 왜 이렇게 작동하는가**의 본질을 설명하는 이론임을 강조합니다.

### 5.2.1 Data Elements

기존의 분산 아키텍처에서는 모든 내부 데이터를 숨겼지만 REST에서는 형태와 위치가 중요하다고 주장합니다.

왜냐면 REST는 **데이터를 옮겨서 보여주는** 구조를 가정하기 때문이라고 말합니다.

시스템 설계 시, 데이터를 전달하는 방법은 3가지인데,

  - 데이터를 서버에서 렌더링하여 결과만 전송(Client-Server): 데이터가 미리 Representation으로 변환하고 클라이언트가 그걸 **그대로** 보여줍니다.
  클라이언트가 단순해지지만, 서버 부하가 크고 확장성이 낮다는 단점이 있습니다.

  - 데이터 + 렌더링 엔진을 함께 전송(Mobile Object): 코드와 데이터를 함께 보내 정보 은닉과 커스터마이징이 가능하나, 데이터 전송량이 증가하고 클라이언트가 특정 엔징을 요구받습니다.

  - 데이터 + 메타데이터를 전송(REST의 기본): JSON과 헤더에 application/json을 포함해서 보내듯, 서버가 데이터와 메타데이터를 보내고 클라이언트가 렌더링하는 방식입니다.
  확장성이 높고 단순하나 서버와 클라이언트 모두 동일한 데이터 타입으로 맞춰야 합니다.

REST에서는 이 세 가지 방식을 혼합한 아래의 하이브리드 방식을 차용합니다.

  HTTP+URI로 표준 인터페이스를 제공하고, 공유 데이터 타입(JSON, XML, HTML 등)에 기반하여, 데이터와 메타데이터를 전송하여 클라이언트가 직접 처리하도록 하는 방식

이를 통해 REST에서는 서버와 클라이언트 분리를 유지하고, 확장성도 지키면서, 기능 확장도 가능하다는 장점을 가져가게 됩니다.

REST 데이터 요소 요약

  - Resource: 하이퍼텍스트가 가리키는 **개념적** 대상 (ex. "/users/1"이 가리키는 대상)
  - Resource Identifier: 리소스를 식별하는 이름 (ex. URL, URN)
  - Representation: 리소스의 현재 상태를 담은 데이터 (ex. HTML, JSON, JPEG 등 실제로 클라이언트로 전송되는 데이터)
  - Representation Metadata: 표현 데이터의 타입과 상태 정보 (ex. Header의 Content-Type, Last-Modified 등)
  - Resource Metadata: 리소스 자체 정보 (ex. Links, Vary 헤더 등)
  - Control Data: 요청/응답의 목적을 제어하는 데이터 (ex. Cache-Control, If-Modified-Since)

#### 5.2.1.1 Resource and Resource Identifier

REST의 핵심 추상화는 바로 Resource입니다.

Resource는 이름 붙일 수 있는 모든 것입니다.

문서, 이미지, 물리적 객체, 가상의 개념 등을 예로 들 수 있습니다.

수학적으로 표현하면, 시간에 따라 변하는 값들의 집합의 함수로

  R = 리소스
  MR(t) = 시간 t에서 리소스 값의 집합

예를 들자면, /paper/preferred -> 선호되는 논문 버전(시간에 따라 선호도가 변하면서 결과값도 변화)와 /paper/conferenceX -> 학회 발표용 버전(고정값)

이렇게 두 리소스가 있을 때, 같은 데이터를 가리켜도 **의미**적 매핑이 다르기 때문에 다른 리소스로 분류해야 합니다.

즉, 리소스가 데이터 자체가 아니라 **데이터를 지칭하는 개념적 이름**이라고 봐야 한다고 말합니다.

Resource Identifier는 그 개념을 지칭하는 문자열입니다.

Spring으로 예를 들면

  @RestController
  @RequestMapping("/users")
  public class UserController {
  
      @GetMapping("/{id}")
      public ResponseEntity<UserDto> getUser(@PathVariable Long id) {
          return ResponseEntity.ok(userService.findById(id));
      }
  }

  - /users/{id} → Resource Identifier Template
	- /users/1 → Resource Identifier Instance
  - UserDto → Resource Representation

즉,

  Resource Identifier  →  /users/1
  Resource             →  User(id=1)
  Representation       →  {"id":1,"name":"Jason"}

이렇게 세 가지가 합쳐져서 RESTful이 됩니다.

또한 Resource Identifier는 고유성, 불변성, 추상성, 분산 가능성을 가져아합니다.

리소스의 상태가 변하더라도 항상 같은 개념적 대상을 가르켜야하므로 식별자를 설계할 때는 동사적 행위가 들어가면 안되고, 위치만 들어가야합니다.

즉,

  "/createUser", "/getUser/1"

이런 식으로 URL을 명명하는 것은 안된다는 것을 강조합니다.

#### 5.2.1.2 Representation

REST 컴포넌트들은 State를 Representation이라는 형태로 주고받습니다.

필딩은 Representation을 다음과 같이 정의합니다.

  A representation is a sequence of bytes, plus representation metadata to describe those bytes.

  Representation = byte 시퀀스 + byte 메타데이터

예를 들어, 서버가 클라이언트에 JSON 형태로 응답을 보내면, JSON이 해당 리소스의 표현(Representation)이 됩니다.

표현의 구성요소로,

  - Data: 실제 데이터
  - Representation Metadata: 표현 메타데이터(Content-Type, Content-Length 등)
  - Resource Metadata: 리소스 부가 정보(ETag, Last-Modified 등)
  - Control Data: 요청/응답 목적 제어(Cache-Control, If-Modified-Since 등)

표현의 의미는 요청의 목적(HTTP 메소드)에 따라 표현이 달라질 수 있습니다.

  - GET: 현재 상태 표현(조회)
  - POST: 새 상태 전송(생성)
  - PUT: 변경할 상태 전송(수정)
  - DELETE: 상태 삭제 요청(삭제)

표현의 형태는 Media Type으로 정의합니다.

이러한 Media Type의 설계는 사용자 체감 성능에 직접적인 영향을 미친다고 필딩은 주장합니다.

그러면 예를 하나 드는데, 네트워크 상태가 같아도 HTML의 경우 브라우저가 점진적으로 렌더링하므로 사용자 체감 성능이 완전히 다 받아서 한꺼번에 실행하는 것보다 좋게 느껴진다고 주장합니다.

그렇기 때문에, 어떤 Media Type을 선택할지도 UX와 성능에 직접적인 영향을 미친다고 강조합니다.

### 5.2.2 Connectors

REST는 리소스에 접근하고 리소스의 표현을 전송하는 활동을 캡슐화하기 위해 다양한 커넥터를 사용합니다.

즉, 커넥터는 컴포넌트 내 통신 경로를 추상화한 계층입니다.

커넥터에는

  - client(Postman, 브라우저, REST Template): request를 시작, 서버로 request를 보내 response를 받음.
  
  - server(Spring 내장 Tomcat, Nginx, Apache): 서비스 접근을 제공, request를 받아 response를 제공, 하나의 컴포넌트가 server와 client 커넥터 모두 가질 수 있음(API Gateway가 그 예)
  
  - cache(브라우저 캐시, 캐시 네트워크 등): 클라이언트나 서버 인터페이스에 존재, 재사용 가능한 응답 저장하여 재활용. 캐시는 해당 컴포넌트의 메모리 공간에서 구현.
  클라이언트에서는 브라우저 캐시나 HTTP 캐시 등으로 네트워크 트래픽 감소에 기여하고, 서버에서는 같은 요청에 응답을 줄여 서버 부하를 줄여줌.
  공유 캐시는 여러 클라이언트가 같은 캐시를 사용함. 서버 부하가 감소하나 데이터의 최신성을 맞춰주지 않으면 신뢰도가 떨어지고 너무 최신성을 자주 업데이트하면 효율이 떨어짐.
  기본적으로 GET요청은 캐시가 가능하나, POST, PUT, DELETE는 캐시 불가. 사용자 인증이나 공유 금지된 응답은 개인 캐시에서만 사용가능. 이러한 캐시 정책을 Cache-Control등의 제어 데이터로 명시 가능
  
  - resolver(bind 등): URI를 실제 네트워크 주소로 변환. "http://www.example.com"이 있다면, "example.com"을 DNS resolver로 IP 주소로 변환.
  이렇게 resolver를 두게 되면, ip주소가 변경되어도 리소스 접근이 유지되지만 지연 시간이 증가함.
  
  - tunnel(SSL, SOCKS 등): 방화벽 등의 단순 중계자. 일부 REST의 컴포넌트들은 동적으로 터널 모드로 전환이 가능함.
  예를 들어, HTTP 프록시가 CONNECT 메소드를 수신하여 SSL 연결 요청을 받으면 SSL 프로토콜 통신을 위한 터널로 바뀜. 연결이 종료되면 터널도 사라짐

이러한 유형이 있으며, 컴포넌트 간 통신을 위해 추상적 인터페이스를 제공합니다.

추상화 인터페이스로 구현 교체도 가능합니다.

즉, 통로가 추상화되어 내부 구현을 바꿔도 사용자에게 영향이 가지 않습니다.

그렇기 때문에, 컴포넌트들은 직접 연결되는 것이 아니라 커넥터라는 내장 네트워크 모듈을 통해 간접적으로 연결되는 구조를 가지게 됩니다.

Spring의 경우, 이러한 연결을 위해 내장 Tomcat을 기본적으로 제공하고, 다른 서비스 호출을 위해선 Client Connector를 사용합니다.

모든 REST의 요청은 stateless입니다.

상태를 저장하지 않기 때문에, 각 요청은 이전 요청과 독립적이며, 요청을 이해하는데 필요한 모든 정보가 요청에 포함되어야 합니다.

이러한 제약으로,

  1. 상태 저장 불필요: 요청 간 상태 기억 불필요(리소스 절약 + 확장성 향상)
  2. 병렬 처리 용이: 요청 간 의존이 없어 여러 요청을 동시 수행
  3. 중개자 이해 가능: 요청이 독립적이어서 중간 계층에서도 요청 분석 가능
  4. 캐싱 효율성 향상: 재사용 가능한 응답을 만들 수 있음

이런 효과를 얻을 수 있습니다.

커넥터의 인터페이스는 Procedural Invocation과 비슷하지만, 매개변수를 주고받는 방식에는 차이가 있습니다.

  - 입력 매개변수: 요청 제어 데이터, 리소스 식별자, 선택적 표현
  - 출력 매개변수: 응답 제어 데이터, 선택적 리소스 메타데이터, 선택적 표현

언뜻 보기에는 동기식 호출로 보일 수도 있지만, 데이터는 스트리밍으로 전달이 가능합니다.

모든 데이터를 다 받고 처리하는게 아니라, 데이터를 받는 동안에도 처리하는 방식으로, 지연 시간을 줄이는 효과가 있습니다.

### 5.2.3 Components

컴포넌틑 네트워크 상의 참여자들로, 역할을 기준으로 구분되었습니다.

커넥터가 통로로써 연결을 담당했다면, 컴포넌트는 통신의 주체로 실제 행위를 합니다.

  - User Agent: 클라이언트 커넥터를 사용하여 request를 시작하고 response의 최종 수신자가 됩니다. 리소스 조작의 시작점으로, 가장 흔히 볼 수 있는 것이 웹 브라우저입니다.

  - Origin Server: 서버 커넥터를 사용해 요청된 리소스의 네임스페이스를 관리합니다. 쉽게 말해, 리소스의 최종 소유자입니다.
  리소스 변경에 관한 요청은 반드시 최종 목적지로 origin server에서 끝나야 합니다. 세부 구현 사항은 표준 인터페이스에 숨겨집니다.

  - Intermediary Components: 중개자로, 클라이언트와 서버 양쪽의 역할을 동시에 수행하는 컴포넌트입니다. 요청과 응답을 forward(전달)하거나 transition(변환)합니다.
  Proxy와 Gateway가 있습니다.

    - Proxy: 클라이언트가 선택하여 사용되는 클라이언트의 대리자입니다. 클라이언트는 프록시를 통해 요청을 대신 보내며, 프록시가 원 서버로 요청을 전달하고 응답을 되돌려줍니다.
    다른 서비스의 인터페이스 캡슐화, 데이터 변환, 성능 향상, 보안 강화를 목적으로 합니다.
  
    - Gateway(Reverse Proxy): 네트워크나 서버 쪽에서 강제로 두는 중개자입니다. 내부 서비스들을 외부로부터 보호하고, 데이터 변환, 성능 향상, 보안 등을 수행합니다.
    Proxy와 Gateway의 차이는 **누가 선택하느냐**입니다. Proxy는 클라이언트가, Gateway는 서버 또는 네트워크가 구성해서 클라이언트가 강제로 통과하도록 하게 끔 합니다.

정리하면, REST에서 컴포넌트는 실제 행위자로, User Agent가 요청을 시작 -> Proxy/Gateway가 요청 중개 및 필터 -> Origin Server가 최종 응답이라는 흐름이 완성됩니다.


## 5.3 REST Architectural View

이 절에서는 REST 아키텍처 스타일이 실제로 어떻게 작동하는지를 입체적으로 설명합니다.

### 5.3.1 Process View

실제 시스템에서는 매우 많은 컴포넌트들이 상호작용하여 전체 데이터 흐름이 세부사항에 가려져 복잡하게 보이는 경우가 많다고 말합니다.

