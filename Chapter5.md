# 5. Network-based Architectural Styles

## 5.1 Deriving REST

웹 아키텍처는 필딩이 계속 강조하듯, **제약의 집합**을 언급합니다.

제약이 추가됨에 따라 속성이 바뀌고, 이를 통해 REST 아키텍처 스타일을 만들 수 있다고 합니다.

### 5.1.1 Null Style

건축이나 소프트웨어나 아키텍처 설계 과정에서 두 가지 관점이 존재한다고 언급합니다.

하나는 백지 상태에서 익숙한 요소들을 쌓아가며 요구사항을 만족시키는 creative build-up과,

전체 시스템을 상상하여 제약을 계속 추가하며 자연스럽게 행동을 조율하는 constraint-driven design 방식이 존재합니다.

전자는 창의성과 무한한 비전을, 후자는 절제와 문맥의 이해를 강조합니다.

REST는 후자의 방식을 택합니다.

널 스타일은 아무런 제약도 존재하지 않는 상태를 말합니다.

컴포넌트 간의 경계가 없고, 모든 요소가 하나로 묶여있으며 아무런 구조나 규칙이 없는 자유 상태입니다.

REST 이러한 "백지 상태"에서 출발하여 하나씩 더해갑니다.

### 5.1.2 Client-Server Style

클라이언트-서버 스타일은 네트워크 기반 아키텍처에서 흔히 사용되는 아키텍처 스타일로,

서버가 여러 클라이언트들에게 동일한 서비스를 제공하며, 클라이언트는 request를 통해 통신을 시작하고 서버는 요청을 listen하여 response를 반환합니다.

여기서 커넥터의 역할을 네트워크 프로토콜이 맡습니다.

핵심은 UI와 Data Storage를 분리했다는 점입니다.

클라이언트는 UI부분만을 맡고, 서버는 데이터 저장과 관리를 담당하여 데이터와 데이터를 사용하는 앱이 독립적으로 존재할 수 있게 됩니다.

인터페이스가 변하지 않는다면, 서버와 클라이언트 각각 독립적으로 진화할 수 있습니다.

UI는 이식성이 올라가고 클라이언트의 변경이 서버에 영향을 주지 않아 유지보수성도 올라가며 서버는 확장성이 증가하게되어 서버가 단순해질수록 여러 클라이언트가 동시에 동일한 서버를 사용할 수 있게 됩니다.

그러나, 네트워크 특성상 오버헤드가 발생하고 데이터 변환과 송수신 과정에서 효율성이 떨어지며 Latency가 발생합니다.

또한 가시성이 낮기 때문에, 실제 데이터 흐름의 파악이 어려워 비효율적인 네트워크 사용이 발생할 수 있습니다.

그럼에도 이러한 모든 단점을 상쇄하는 강력한 장점들로, 대부분의 분산 시스템의 기초이자 웹 아키텍처의 핵심으로 자리잡았습니다.

### 5.1.3 Stateless Style

REST 철학의 핵심인 stateless 아키텍처 스타일입니다.

클라이언트-서버 스타일을 계승하였습니다.

서버는 이전 요청이 저장된 컨텍스트를 사용하지않고 매 요청마다 해당 요청을 이해하는데 필요한 모든 정보를 자체적으로 포함하는 스타일입니다.

즉, 서버는 요청 간 상태를 기억(저장)하지 않는다는 것이 핵심입니다.

Session은 전적으로 클라이언트가 관리하고, 요청을 처리하는 동안에만 애플리케이션 상태를 임시로 저장할 뿐, 응답을 보내면 요청에 대한 정보를 모두 잊습니다.

각 요청이 독립적이므로 가시성이 향상되고, 요청의 실패가 다른 요청에게 영향을 주지 않아 신뢰성이 올라가며, 서버가 모든 클라이언트들의 상태를 저장할 필요가 없어 서버 부담이 줄어들어 확장성에도 좋습니다.

그러나, 클라이언트가 매번 똑같은 정보를 중복으로 보내야하므로 성능이 저하될 수 있고, Latency가 발생하여 체감 속도가 더 느려질 수 있습니다.

그럼에도 불구하고, 대규모 분산 시스템에서는 신뢰성과 확장성이 생명이므로 이런 문제를 감수할 가치가 있어 자주 사용됩니다.

그러면 실제로 State는 어떤 종료가 있었을까요?

필딩은 암묵적으로 Application State(사용자의 작업 단계), Resource State(서버의 리소스 상태 관리 단계)를 구분합니다(REST의 HATEOAS로 이어집니다).

필딩은 Stateless 스타일 덕분에 웹이 폭발적으로 성장할 수 있었다고 합니다.

웹 서버 입장에서는 클라이언트를 몰라도 요청의 형식만 맞으면 처리가 가능하므로, 웹의 확장성과 신뢰성에 큰 영향을 미친 설계 철학이라고 평가합니다.

### 5.1.4 Cache Style

Stateless의 경우, 매번 중복되는 데이터를 반복해서 보내야하는 치명적인 단점이 있었는데, 이걸 해결하기 위해 등장한 아키텍처 스타일이 바로 Cache입니다.

응답이 캐시 가능하다면, 클라이언트는 동일한 요청에 대해서 응답 데이터를 재사용할 권한을 갖습니다.

HTTP에서는 이러한 캐시 가능성(Cacheable)을 표시하기 위해서, Cache-Control, Expires, ETag, Last-Modified같은 헤더를 사용합니다.

즉, 서버가 캐싱 정책을 선언하고 클라이언트가 전적으로 따르는 구조입니다.

캐시 스타일을 통해, latency를 줄여 상호작용을 일부분 혹은 완전히 제거할 수 있게 됩니다.

성능 향상은 물론이고, 효율성과 확장성 또한 증가하게 됩니다.

하지만 그에 대한 trade-off(대가)로, 캐시된 데이터가 오래되어(stale), 최신 데이터의 불일치가 발생하게 되면 신뢰성이 저하될 수 있습니다.

따라서 캐시 제약을 아키텍처 스타일로 사용하게 될 경우, 만료 시간같은 응답 제어 정보를 신중히 정의해야 합니다.

캐시 제약 또한 클라이언트-서버 스타일에서 파생되었으며, stateless 스타일과 결합할 수 있습니다.

### 5.1.5 Uniform Interface

REST는 컴포넌트 간 **일관된 인터페이스**가 핵심이라고 언급합니다.

즉, 모든 컴포넌트가 같은 형식으로 대화한다는 것입니다.

각 구현체(또는 컴포넌트)는 자신의 서비스와 느슨하게 결합되어 독립적인 진화가 가능해진다는 것입니다.

그러나 표준화된 인터페이스를 요구하므로 전용 인터페이스에 비해 효율이 떨어질 수 있어서, 실시간 스트리밍이나 RPC에는 최적이 아닐 수도 있다고 강조합니다.

일관된 인터페이스를 위해서는 

  1. 리소스 식별: 고유 식별자인 URI로 식별되어야 하고
  2. 표현을 통한 리소스 조작: 리소스는 Representation(리소스의 표현 - json, mime 등)을 통해서만 조작한다.
  3. 자기 설명 메시지: 모든 메시지는 자기 자신을 설명하여 메시지만으로 요청의 의미를 파악 가능해야 한다.
  4. 하이퍼링크로 상태 전이(HATEOAS): 앱의 상태 전이는 하이퍼미디어 링크를 통해 이루어진다.

를 지켜야하며 이것의 자세한 내용은 5.2절에서 이어진다고 합니다.

### 5.1.6 Layered System Style

네트워크의 확장성과 보안, 중개, 로깅 구조 등의 유지보수성을 설명하는 부분입니다.

즉, 현대의 Proxy, Gateway, Load Balancer, CDN 등이 왜 REST에 들어가게 되었는지 나타나게 됩니다.

아키텍처가 계층적 구조로 구성되어, 각 컴포넌트들은 동작을 제약하고, 직접 상호작용하는 인접 계층 외에는 볼 수 없다는 제약이 적용됩니다.

이렇게 **지식을 제한**하여 단순성을 증가시키고, 교체가 가능하며, 진화 가능하고 설정의 자유로움을 개선할 수 있습니다.

개별 계층을 분리 가능하므로 보안이 강화되고 확장성이 향상되며, 부하 분산도 가능해지고, 레거시 시스템을 캡슐화하는 것이 가능해집니다.

그러나, 계층을 나눈다는 특성으로 인해 오버헤드와 latency가 증가하여 성능이 저하되고 중간 계층에 장애 발생 시 신뢰성이 떨어지게 됩니다.

REST는 이러한 단점에도 대규모 분산 시스템에서 Layered System이 주는 확장성과 유지보수성의 이득이 압도적이므로 사용될 수 밖에 없다고 주장합니다.

주요 중간 계층으로

  - Proxy: 요청 캐싱, 로깅, 필터링
  - Gateway: API 라우팅, 인증, 로드 밸런싱
  - CDN: 정적 리소스 캐싱
  - Load Balancer: 트래픽 분산
  - Security: 방화벽, 토큰 검증 등

이 존재하며, REST는 단순 클라이언트 - 서버 구조만을 허용하는 것이 아닌 보다 유연한 구조를 허용합니다.

### 5.1.7 Code-On-Demand

REST는 클라이언트 기능 확장을 위해 applet이나 script 형태의 코드를 서버로부터 받아 실행하는 방식으로,

클라이언트 단순화를 통한 확장성 증가를 허용하나, 가시성이 떨어지기에 선택적 제약으로만 두었다고 밝힙니다.

즉, 해당 제약은 항상 적용되는 것이 아니라 특정 환경에서 선택하여 적용 가능하다는 것을 의미합니다.

현대 웹에선 주로 Javascript가 쓰이므로 이를 예로 들어보면, 

Code-On-Demand는 웹 클라이언트가 서버에 요청하면 서버가 데이터와 Javascript코드까지 같이 주는 구조를 말합니다.

물론 이는 필딩이 처음에는 당시 웹 환경을 고려해서 정적 컨텐츠로만 한정하였기에 옵션으로 두었으나

React가 등장하면서 각종 javascript 기반 웹 클라이언트가 나오면서 사실상 필수처럼 여겨지고 있습니다.

그러나 이는 다시 필딩이 예견했던 것처럼 가시성의 문제로 이어져 API 추적이 힘들어지게 되었고, 다시 BFF(Backend-For-Frontend)가 등장하게 되는 계기가 됩니다.

## 5.2 REST Architectural Elements

REST는 내부 구현이나 프로토콜이 아니라 **웹이 왜 이렇게 작동하는가**의 본질을 설명하는 이론임을 강조합니다.

### 5.2.1 데이터 요소

기존의 분산 아키텍처에서는 모든 내부 데이터를 숨겼지만 REST에서는 형태와 위치가 중요하다고 주장합니다.

왜냐면 REST는 **데이터를 옮겨서 보여주는** 구조를 가정하기 때문이라고 말합니다.

시스템 설계 시, 데이터를 전달하는 방법은 3가지인데,

  - 데이터를 서버에서 렌더링하여 결과만 전송(Client-Server): 데이터가 미리 Representation으로 변환하고 클라이언트가 그걸 **그대로** 보여줍니다.
  클라이언트가 단순해지지만, 서버 부하가 크고 확장성이 낮다는 단점이 있습니다.

  - 데이터 + 렌더링 엔진을 함께 전송(Mobile Object): 코드와 데이터를 함께 보내 정보 은닉과 커스터마이징이 가능하나, 데이터 전송량이 증가하고 클라이언트가 특정 엔징을 요구받습니다.

  - 데이터 + 메타데이터를 전송(REST의 기본): JSON과 헤더에 application/json을 포함해서 보내듯, 서버가 데이터와 메타데이터를 보내고 클라이언트가 렌더링하는 방식입니다.
  확장성이 높고 단순하나 서버와 클라이언트 모두 동일한 데이터 타입으로 맞춰야 합니다.

REST에서는 이 세 가지 방식을 혼합한 아래의 하이브리드 방식을 차용합니다.

  HTTP+URI로 표준 인터페이스를 제공하고, 공유 데이터 타입(JSON, XML, HTML 등)에 기반하여, 데이터와 메타데이터를 전송하여 클라이언트가 직접 처리하도록 하는 방식

이를 통해 REST에서는 서버와 클라이언트 분리를 유지하고, 확장성도 지키면서, 기능 확장도 가능하다는 장점을 가져가게 됩니다.

REST 데이터 요소 요약

  - Resource: 하이퍼텍스트가 가리키는 **개념적** 대상 (ex. "/users/1"이 가리키는 대상)
  - Resource Identifier: 리소스를 식별하는 이름 (ex. URL, URN)
  - Representation: 리소스의 현재 상태를 담은 데이터 (ex. HTML, JSON, JPEG 등 실제로 클라이언트로 전송되는 데이터)
  - Representation Metadata: 표현 데이터의 타입과 상태 정보 (ex. Header의 Content-Type, Last-Modified 등)
  - Resource Metadata: 리소스 자체 정보 (ex. Links, Vary 헤더 등)
  - Control Data: 요청/응답의 목적을 제어하는 데이터 (ex. Cache-Control, If-Modified-Since)

#### 5.2.1.1 Resource and Resource Identifier
