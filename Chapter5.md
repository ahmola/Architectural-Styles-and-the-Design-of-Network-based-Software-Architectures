# 5. Network-based Architectural Styles

## 3.1 Classification Methodology

저자는 소프트웨어를 만드는 것이 **요구사항 충족**에 있지, topology나 component type을 위한 것이 아니라고 처음부터 강조합니다.

즉, 요구사항을 **맞추는**거지, 요구사항이 아키텍처 스타일에 어거지로 맞춰지면 안된다는 것입니다.

아키텍처 스타일을 분류하는 기준은 어떤 유형의 구조가 아니라(그러니까 Client-Server 구조다, Layered구조다 이런 식이 아니라는 것)

스타일이 어떤 품질(Performance, Scalability)를 창출해내는지로 나누게 된다고 합니다.

그리고 REST는

  - Client-Server
  - Layered System
  - Cacheable
  - Stateless
  - Code-On-Demand

위 스타일들의 제약을 통합한 아키텍처 스타일입니다.

## 3.2 Client-Server Style

클라이언트-서버 스타일은 네트워크 기반 아키텍처에서 흔히 사용되는 아키텍처 스타일로,

서버가 여러 클라이언트들에게 동일한 서비스를 제공하며, 클라이언트는 request를 통해 통신을 시작하고 서버는 요청을 listen하여 response를 반환합니다.

여기서 커넥터의 역할을 네트워크 프로토콜이 맡습니다.

핵심은 UI와 Data Storage를 분리했다는 점입니다.

클라이언트는 UI부분만을 맡고, 서버는 데이터 저장과 관리를 담당하여 데이터와 데이터를 사용하는 앱이 독립적으로 존재할 수 있게 됩니다.

인터페이스가 변하지 않는다면, 서버와 클라이언트 각각 독립적으로 진화할 수 있습니다.

UI는 이식성이 올라가고 클라이언트의 변경이 서버에 영향을 주지 않아 유지보수성도 올라가며 서버는 확장성이 증가하게되어 서버가 단순해질수록 여러 클라이언트가 동시에 동일한 서버를 사용할 수 있게 됩니다.

그러나, 네트워크 특성상 오버헤드가 발생하고 데이터 변환과 송수신 과정에서 효율성이 떨어지며 Latency가 발생합니다.

또한 가시성이 낮기 때문에, 실제 데이터 흐름의 파악이 어려워 비효율적인 네트워크 사용이 발생할 수 있습니다.

그럼에도 이러한 모든 단점을 상쇄하는 강력한 장점들로, 대부분의 분산 시스템의 기초이자 웹 아키텍처의 핵심으로 자리잡았습니다.

## 3.3 Stateless Style

REST 철학의 핵심인 stateless 아키텍처 스타일입니다.

클라이언트-서버 스타일을 계승하였습니다.

서버는 이전 요청이 저장된 컨텍스트를 사용하지않고 매 요청마다 해당 요청을 이해하는데 필요한 모든 정보를 자체적으로 포함하는 스타일입니다.

즉, 서버는 요청 간 상태를 기억(저장)하지 않는다는 것이 핵심입니다.

Session은 전적으로 클라이언트가 관리하고, 요청을 처리하는 동안에만 애플리케이션 상태를 임시로 저장할 뿐, 응답을 보내면 요청에 대한 정보를 모두 잊습니다.

각 요청이 독립적이므로 가시성이 향상되고, 요청의 실패가 다른 요청에게 영향을 주지 않아 신뢰성이 올라가며, 서버가 모든 클라이언트들의 상태를 저장할 필요가 없어 서버 부담이 줄어들어 확장성에도 좋습니다.

그러나, 클라이언트가 매번 똑같은 정보를 중복으로 보내야하므로 성능이 저하될 수 있고, Latency가 발생하여 체감 속도가 더 느려질 수 있습니다.

그럼에도 불구하고, 대규모 분산 시스템에서는 신뢰성과 확장성이 생명이므로 이런 문제를 감수할 가치가 있어 자주 사용됩니다.

그러면 실제로 State는 어떤 종료가 있었을까요?

필딩은 암묵적으로 Application State(사용자의 작업 단계), Resource State(서버의 리소스 상태 관리 단계)를 구분합니다(REST의 HATEOAS로 이어집니다).

필딩은 Stateless 스타일 덕분에 웹이 폭발적으로 성장할 수 있었다고 합니다.

웹 서버 입장에서는 클라이언트를 몰라도 요청의 형식만 맞으면 처리가 가능하므로, 웹의 확장성과 신뢰성에 큰 영향을 미친 설계 철학이라고 평가합니다.

## 3.4 Cache Style

Stateless의 경우, 매번 중복되는 데이터를 반복해서 보내야하는 치명적인 단점이 있었는데, 이걸 해결하기 위해 등장한 아키텍처 스타일이 바로 Cache입니다.

응답이 캐시 가능하다면, 클라이언트는 동일한 요청에 대해서 응답 데이터를 재사용할 권한을 갖습니다.

HTTP에서는 이러한 캐시 가능성(Cacheable)을 표시하기 위해서, Cache-Control, Expires, ETag, Last-Modified같은 헤더를 사용합니다.

즉, 서버가 캐싱 정책을 선언하고 클라이언트가 전적으로 따르는 구조입니다.

캐시 스타일을 통해, latency를 줄여 상호작용을 일부분 혹은 완전히 제거할 수 있게 됩니다.

성능 향상은 물론이고, 효율성과 확장성 또한 증가하게 됩니다.

하지만 그에 대한 trade-off(대가)로, 캐시된 데이터가 오래되어(stale), 최신 데이터의 불일치가 발생하게 되면 신뢰성이 저하될 수 있습니다.

따라서 캐시 제약을 아키텍처 스타일로 사용하게 될 경우, 만료 시간같은 응답 제어 정보를 신중히 정의해야 합니다.

캐시 제약 또한 클라이언트-서버 스타일에서 파생되었으며, stateless 스타일과 결합할 수 있습니다.

## 3.5 Layered System Style

네트워크의 확장성과 보안, 중개, 로깅 구조 등의 유지보수성을 설명하는 부분입니다.

즉, 현대의 Proxy, Gateway, Load Balancer, CDN 등이 왜 REST에 들어가게 되었는지 나타나게 됩니다.

아키텍처가 계층적 구조로 구성되어, 각 컴포넌트들은 동작을 제약하고, 직접 상호작용하는 인접 계층 외에는 볼 수 없다는 제약이 적용됩니다.

이렇게 **지식을 제한**하여 단순성을 증가시키고, 교체가 가능하며, 진화 가능하고 설정의 자유로움을 개선할 수 있습니다.

개별 계층을 분리 가능하므로 보안이 강화되고 확장성이 향상되며, 부하 분산도 가능해지고, 레거시 시스템을 캡슐화하는 것이 가능해집니다.

그러나, 계층을 나눈다는 특성으로 인해 오버헤드와 latency가 증가하여 성능이 저하되고 중간 계층에 장애 발생 시 신뢰성이 떨어지게 됩니다.

REST는 이러한 단점에도 대규모 분산 시스템에서 Layered System이 주는 확장성과 유지보수성의 이득이 압도적이므로 사용될 수 밖에 없다고 주장합니다.

주요 중간 계층으로

  - Proxy: 요청 캐싱, 로깅, 필터링
  - Gateway: API 라우팅, 인증, 로드 밸런싱
  - CDN: 정적 리소스 캐싱
  - Load Balancer: 트래픽 분산
  - Security: 방화벽, 토큰 검증 등

이 존재하며, REST는 단순 클라이언트 - 서버 구조만을 허용하는 것이 아닌 보다 유연한 구조를 허용합니다.

