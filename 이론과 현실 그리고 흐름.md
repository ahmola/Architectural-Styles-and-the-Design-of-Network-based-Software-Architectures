# 이론과 현실 그리고 흐름

이 문서는 논문 발표 당시(1999)에 필딩이 주장한 것과 현재의 괴리에 대한 고찰을 담았습니다.

## 필딩의 문제인식

필딩은 기본적으로 웹이 API를 전부 다 몰라도 링크를 타고 자연스럽게 흘러가는 구조를 이상적으로 바라봤습니다. 

  {
    "user": { "id": 1, "name": "john" },
    "_links": {
      "self": { "href": "/users/1" },
      "posts": { "href": "/users/1/posts" }
    }
  }

즉, 이런 식으로 "_links"로부터 얻은 url을 통해 하이퍼링크로 **직접**이동하는 방식으로 웹을 바라봤기 때문입니다.

그러나 현대 웹에서는 사람이 직접 모든 링크를 조작하는게 아니라 클라이언트가 모든 걸 대신 처리해주는 **서버-서버**의 구조로 진화하였습니다.

그러니까, 하이퍼미디어를 통한 이동이 필요가 없어진 것입니다.

또한 Stateless가 핵심 전제이기에, 모든 요청에 인증 정보(사용자 로그인 정보 등)이 포함되어야 했는데, 이걸 위해서는 결국 세션 관리가 필수적이었습니다.

그래서 초기에는 이러한 이상과 현실의 타협으로 나온 구조가 세션+쿠키의 구조였습니다.

필딩은 stateless라는 전제에 정면으로 위배되는 쿠키를 싫어했습니다.

6장에서 정보은닉, 서버 확장성, 캐시 효용을 깨뜨린다는 이유에서였습니다.

이후, 현대에는 JWT같은 토큰 형태로 진화하였습니다.

이유는 현대의 웹이 즉각적인 반응(Redis나 Gateway 등과 상태 공유)를 중시하는 방향으로 진화하였기 때문입니다.

즉, 웹이 느리고 지속적인게 아니라 **빠르고 즉각적인** 방향으로 진화해서였습니다.

## 왜 틀린 방향으로 갔나?

일단 들어가기 전에, 상태(State)에 대해 간단하게 짚고 넘어갑시다.

  상태 = **현재** 어디서 무엇을 하고 다음에는 무엇을 할 수 있는지

  - 시스템 상태: 서버, 프로세스, 네트워크 등의 현재 정보
  - 애플리케이션 상태: 사용자가 사용 중인 앱의 현재 정보 또는 맥락(로그인 여부, 현재 페이지, 머문 시간 등)
  - 리소스 상태: 저장된 데이터의 현재 값

  대부분의 특별한 말이 없다면 애플리케이션의 상태를 말합니다.

사실 이건 이유가 아주 명확했습니다.

React와 Single Page Application 패러다임이 등장하였기 때문입니다.

필딩은 정적 하이퍼미디어 웹을 이상화한 모델을 전제로 REST를 설계하였습니다.

웹 하나 당 상태 하나였던 시대였기에 때문이었습니다.

Facebook에서 React를 발표하면서 웹은 완전히 다른 방향으로 진화하게 되었습니다.

React는 UI 렌더링을 누가 할 것인지와 상태 관리의 위치였습니다.


  클라이언트가 UI를 렌더링하고, 
  상태가 달라지면 가상 DOM이 렌더링해주고, 
  서버 응답을 HTML이 아닌 JSON으로 받고, 
  하이퍼미디어가 아닌 JS코드로 받으며
  프레임워크가 상태를 제어

하는 방식으로 완전히 바뀌게 됩니다.

상태를 완전히 서버가 관리하게 된 것입니다.

이는 사실상 엄청난 충격이었습니다. 왜냐면 HTML문서를 한 번만 받고 상태 전이는 JS코드를 통해서 클라이언트가 Router로 직접 제어하는 방식으로 바뀌었습니다.

즉, 한 번에 하이퍼미디어가 쓸모없어지게 된 것입니다.

클라이언트가 모든 상태를 관리하게 되면서 거대해지는 Stateful SPA 모델이 등장하게 된 것입니다.

서버는 stateless지만 클라이언트는 stateful하게 바뀌게 된 것입니다.

또한, React에서는 HTML을 한번만 받고 JS코드에서 JSON을 통해 표현(Representation)을 받게 되었습니다.

서버가 뷰 렌더링(Thymeleaf, JSP 등)하는 방식이 아니라 클라이언트가 뷰 렌더링하는 방식으로 바뀌게 되었습니다.

REST가 뷰를 생성하기 때문에, 사람이 Representation을 소비하는게 아니라, JS코드가 소비하는 주체로 바뀌게 됩니다.

덕분에, 서버가 클라이언트 상태를 주도하는게 아니라 클라이언트가 필요한 데이터만을 명시적으로 요청하거나(GraphQL), BFF(Backend-For-Frontend)로 API를 따로 관리하게 되었습니다.

즉, 기존의 서버 중심의 REST가 클라이언트 주도로 바뀌게 되었습니다.

## 변천사

필딩의 논문이 발표된 직후 불과 10년뒤에 엄청난 변화가 일어나기 시작했습니다.

2010년부터 **AJAX와 jquery의 등장**으로 JSON을 중심으로 웹이 렌더링되면서 **데이터 중심**의 RESTful API 시대가 열리게 되었습니다.

이 때부터, 프론트엔드와 백엔드의 완전한 분리가 생겨났고 필딩의 HATEOAS는 사실상 사장되었습니다.

2015년에는 **Facebook에서 React**가 탄생하게 됩니다.

클라이언트가 애플리케이션, 그러니까 시스템 전체를 삼켜버리게 됩니다.

UI 렌더링을 클라이언트가 주도하게 되고, 기존의 선택이던 Code-on-Demand는 필수가 되어 HTML은 한 번만 받는 대신 JS로 모든 UI를 조작하게 됩니다.

서버가 상태 전이하는게 아니라 클라이언트가 시스템의 상태를 스스로 제어하도록 바뀌게 된 것입니다.

2018년부터는 **GraphQL과 MSA, AWS 등의 기술이 등장**하였습니다.
  
  클라이언트는 필요한 데이터만 쿼리하게 되었고(GraphQL), 
  서버는 단일 REST 아키텍처가 아닌 여러 서비스로 쪼개지며(MicroService Architecture),
  단일 인터페이스에서 명세 기반 질의

라는 변화를 겪게 됩니다.

REST에서 말한 단일 인터페이스로는 모바일, IoT, 웹 등의 여러 생태계와 플랫폼이 공존하는 현대의 시스템에서는 방대한 데이터를 감당하지 못하는 현상이 발생하게 되었기 때문입니다.

2023년부터는 **이벤트 중심, 스트리밍 중심으로 웹이 하나의 네트워크로** 존재하게 됩니다.

전통적인 REST 아키텍처를 따르는 서버 대신, Edge 컴퓨팅과 Lambda함수가 응답하며 상태는 클라우드 전역에서 계속해서 바뀌는 형식으로 존재하게 됩니다.

이제는 client-server라는 구분조차 사라지게 된 것입니다.

  클라이언트(웹 브라우저, IoT 등) -> Edge Layer(CloudFlare, Fly.io 등) -> Core Cloud/Origin Server(AWS, GCP, Kubernetes 등) -> Data Storage(DB 등)

단일 데이터센터로 가면서 성능이 급격하게 저하되자 사용자와 가까운 서버에서 처리하자는 발상이 생겼고,

이런 구조로 진화하게 되어 클라이언트는 물리적으로 가까운 edge서버에서 클라우드의 서비스를 대신 빠르게 처리해주게 되었습니다.

기존 CDN(Content Delivery Network)가 정적 컨텐츠만을 캐싱하여 제공하였다면, Edge는 코드를 대신 실행해서 동적으로 즉시 처리하는 작업을 맡게 되었습니다.

상태는 네트워크의 edge에 존재하고 API의 집합이 아닌 분산된 상태로 떠돌아다니는 형태로 바뀌게 된 것입니다.

즉, 요청을 최대한 가까운 곳에서 빠르게 처리하고 핵심 비즈니스 로직을 중앙에서 처리하는 구조로 바뀌게 되었습니다.
