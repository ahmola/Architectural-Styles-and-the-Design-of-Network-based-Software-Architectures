## 1. Software Architecture

### 1.1 Run-time Abstraction

소프트웨어 아키텍처의 핵심은 **추상화**입니다.

**캡슐화**를 통해 시스템의 세부 사항을 감추고 속성을 더 잘 식별하고 유지하기 위함이라고 저자는 주장합니다.

시스템의 아키텍처는 여러 추상화 수준으로 구성되며, 추상화의 한 형태로 존재하게 됩니다. 또한 각 추상화 수준에서 구현된 컴포넌트들 내 아키텍처가 각각 존재할 수 있다고 말합니다.

이러한 아키텍처의 재귀적 구조는 결국 분해할 수 없는 가장 기본적인 시스템 요소까지 이르게 합니다.

소프트웨어는 여러 추상화 수준과 동작 단계들로 구성되며, [시작, 초기화, 정상 동작, 재초기화, 종료] 등의 운영 단계를 가집니다.

그러나, 단순 동작뿐만 아니라 단계 간 전이(transition)도 아키텍처 또한 기술할 수 있어야 한다고 로이 필딩은 주장합니다.

그렇다면 Structure(구조)와의 차이점은 뭘까요?

아키텍처가 런타임 동작(실행할 때)의 추상화라면, 구조는 정적 소스코드(코드 그 자체)의 구조적 속성을 말합니다.

쉽게 풀어서 설명하면, 소프트웨어 아키텍처는 결국 소스코드가 아니라 실행할 때 시스템이 실제 어떤 형태로 동작하는지를 설명하는 것입니다.

추상화는 간단히 말하면 **분해**하는 것입니다.

복잡한 시스템을 여러 단계로 나눠, 각 단계에서 어떤 역할을 하는지 표현한 것을 말합니다.

예를 들어,

  시스템 수준(사용자 인증 시스템, 실제 서비스의 동작 방식) > 컴포넌트 수준(인증 서비스, 토큰발급 서비스, 유저 정보를 관리하는 서비스 등의 모듈) > 구현 수준(클래스나 메서드와 같은 실제 코드 단위)

이렇게 각 수준에서 각 아키텍철를 가진다고 주장합니다.

운영 단계(phase)별로 아키텍처가 달라진다는 말도 쉽게 예를 들면 이해할 수 있습니다.

Spring에서 설정 파일인 application.yml파일을 읽어서 설정값을 읽고 실행한 후로, 

서버에는 이미 해당 내용이 메모리에 존재하여 설정 파일이 어떻게되든 관계 없어지는, 즉, 더 이상 아키텍처(런타임)과는 관계없는, 아키텍처의 일부가 아닌 것이 되어버립니다.

아키텍처와 구조의 차이도 쉽게 정리하면, 아키텍처는 실행 시에 어떤 동작을 하느냐에 따른 설계이고, 구조는 코드가 어떻게 작성되었느냐의 설계를 말합니다.

그러니까, 아키텍처는 소스코드와 별개로 실행 시에 어떤 상호작용을 하는지에 중점을 두었는지에 대해서 설명합니다.

구조는 소스코드가 작성된 파일에 관한 것이라고 생각하면 됩니다.

필딩은 많은 개발자들이 이러한 개념을 헷갈린다고 말합니다.

아키텍처가 강조하는 서비스 간의 관계이고, 구조는 서비스 내부 구현을 말하는 것이어서 둘이 영향을 주기는 하나 **별개의 설계 행위**라는 것이 로이 필딩이 말하는 핵심입니다.

### 1.2 Elements

아키텍처에는 세 가지 구성요소가 존재한다고 로이 필딩은 말합니다.

  - 컴포넌트 : 작업을 수행하는 단위(연산, 데이터 저장, 인증 등)
  - 커넥터 : 컴포넌트 간의 통신과 상호작용 채널(HTTP, REST API, Kafka gRPC, MQ 등등)
  - 데이터 : 송수신되는 리소스(JSON, Event 등)

로 구성됩니다.

그리고 이 과정에서, 단순히 선과 상자로만 구성된 아키텍처 다이어그램을 지양할 것을 로이 필딩은 주장합니다.

왜냐하면, 아키텍처란 런타임(실행) 환경에서 각 컴포넌트들의 **상호 작용**을 나타내는 것인데, 여기서 상호 작용을 나타내는 **데이터 흐름**이 빠져있기 때문입니다.

데이터가 어떻게 오고 가는지가 시스템의 행동을 결정하는 것, 이것이 REST를 정의하는 주된 이유입니다.

그리고 아키텍처는 Rationale(설계 근거)에 대해서는 과감하게 아키텍처에서 제외하였습니다. 왜냐하면 설계 근거가 실행환경과 아무 상관이 없다고 주장합니다.

예륻 들어, Redis 캐시 서버를 왜 썼는지에 대한 근거가 설계서에 적혀있다고, 실제로 실행할 때 이 근거를 가지고 실행되는게 아니기 때문으로 이해할 수 있습니다.

아키텍처의 핵심은 **실행 중에 데이터가 어떻게 흐르고, 어떤 제약을 갖는지**이지 문서나 설계서가 아니라는 것을 뜻합니다.

즉, 데이터를 중심으로 설계를 해야한다고 주장합니다.
  
    ❌ 나쁜 다이어그램 (Shaw식)
    
    [UserService] ---- [OrderService] ---- [DB]
  
    ✅ 좋은 다이어그램 (Fielding식)
    
    [UserService]
    
     ↑ HTTP (JSON)
    
     ↓
    
    [OrderService]
    
     ↑ JDBC (SQL Query)
     
     ↓
    
    [MySQL DB]

#### 1.2.1 Component

실질적으로 데이터를 받아서 작업을 처리하거나 직접 데이터를 생성하는 **동작의 주체**로, 인터페이스가 정의되어 있고 내부 구현을 신경쓰지 않습니다.

실제 서비스 상에서 컨테이너(또는 파드나 이것들을 포함한 개념) 단위라고 생각하시면 됩니다.

#### 1.2.2 Connector

서로 연결해주는 **통신 채널**로, 데이터를 한 컴포넌트에서 다른 컴포넌트로 전달해줍니다. 데이터를 건드리지 않습니다(내부에 그런 로직이 있을 수도 있으나 일반적인 경우에는 없음).

실제 서비스 상에서 HTTP, TCP Socket, gRPC 등의 프로토콜(또는 그것들을 포함하는 개념) 정도로 이해하시면 됩니다.

#### 1.2.3 Data

실제 송수신되는 데이터로, 커넥터를 통해 알맞은 컴포넌트로 이동되는 **상호작용의 대상**입니다. 컴포넌트 내 숨겨진 메모리 변수 등은 아키텍처 데이터라고 보지 않습니다.

실제 서비스 상에서는 JSON, Message, Event, Stream, File, Serialized Object 등으로 이해하시면 됩니다.

### 1.3 Configurations

시스템의 구조적 형태인 Topology를 나타냅니다.

앞서 언급했던 컴포넌트, 커넥터, 데이터 간의 아키텍처적 관계 구조를 뜻합니다.

구성은 여기서 상호작용하는 컴포넌트와 커넥터의 집합이라고 로이 필딩은 말합니다.

이를 시각적으로 표현하면

	[API Gateway]
	   ↓ REST (JSON)
	[User Service]
	   ↓ JPA (SQL)
	[PostgreSQL DB]

이렇게 표현가능하고 쉽게 말하면 실행 중에 컴포넌트, 커넥터, 데이터가 어떻게 연결되어 있는가를 나타내지를 나타내는 구조입니다.

즉, 아키텍처의 실제 배선도라고 생각하면 됩니다.

그리고 로이 필딩은 여기서 두 가지를 구분하는 것이 중요하다고 강조합니다.

바로 실제 실행 시 연결된 관계(active)와 시스템이 가질 수 있는 모든 관계(potential)을 구분하는 것이 중요하다고 강조합니다.

즉, 실제 연결과 가능한 모든 연결의 차이를 구분하는 것이 중요하다는 것입니다.

이를 강조한 이유는 실제 동작하는 구조와 전체 설계를 혼동하지 않는 것이 중요하기 때문이라고 말합니다.

왜냐면 분산 시스템에서는 기본적으로 **동적**임을 기본으로 하기 때문입니다.

서비스 인스턴스가 줄거나 늘수도 있고, 연결이 끊길 수도 있기 때문입니다. 그래서 Constraints는 모든 구성을 규정하고 Configurations는 활성된 구성을 의미하는 것입니다.

### 1.4 Properties

아키텍처의 제약으로 인해 생기는 품질 속성을 말합니다.

여기서 중요한 점은, 코드가 아니라 설계 패턴과 제약으로 자연스럽게 생기는 성질인 기능적 속성과 비기능적 속성이 존재합니다.

기능적 속성은 시스템 본래의 기능으로 CRUD, 인증, 데이터 처리 등이 이에 해당하고, 비기능적 속성은 구조적 특성으로 인해 생기는 확장성과 유지보수성 등이 이에 해당합니다.

핵심은, 속성은 제약으로부터 유도된다는 것입니다.

여기서 로이 필딩은 Pipe-and-Filter 구조를 예시로 듭니다.

Filter가 실제 데이터를 처리하는 컴포넌트이고 Pipe가 커넥터인데, 여기서의 제약은 Filter는 모두 동일한 인터페이스를 가진다는 것입니다.

이러한 제약으로, 재사용성과 필터 순서를 바꾸면 동작도 바뀌는 구성 가능성이 생기게 됩니다.

즉, 제약으로 인해 품질이 생기는, 자유를 제한하여 시스템 전체가 유연해지는 역설이 발생하게 된다고 주장합니다. **이것이 REST의 핵심 철학입니다.**

설계의 목표는 요구사항보다 더 넓은 품질 집합을 가진 구조를 설계하는 것입니다.

쉽게 말해, API 서버를 설계할 때 단순히 API만 제공하는 것이아니라, 재사용성과 확장성, 유지보수성을 갖춘 구조를 염두해 주고 설계해야 아키텍처가 속성을 가지고 품질이 올라간다고 말하는 것입니다.

시스템의 장기적인 품질은 아키텍처의 제약에서 나오므로, 품질은 제약의 산물이며 좋은 설계는 제약을 잘 거는 것이라고 주장합니다.
