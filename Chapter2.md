# 2. Network-based Application Architectures

## Summaray

웹이 속한 네트워크 기반 애플리케이션 아키텍처란 무엇인지에 대해서 정의하고 좋은 아키텍처의 속성에 대해서 정의합니다.

로이 필딩은 **소프트웨어 아키텍처 전반이 아니라 네트워크 상에서 동작하는 애플리케이션 아키텍처에 한하여** 집중한다고 합니다.

다루는 수준은 애플리케이션 계층 수준입니다.

REST는 네트워크 프로토콜이 아니라, 사용자 행동을 네트워크에 **표현**하는 최적의 구조라고 설명합니다.

그렇다면 좋은 아키텍처는 어떻게 평가하느냐?

제약을 바탕으로 기능적 요구와 비기능적 요구를 분석하고 제약에서 파생된 속성으로부터 품질을 통해 예측할 수 있다고 주장합니다.

가장 중요한 것은, 런타임 환경이 항상 같은 수 없기에 **객관적인 평가 기준은 존재하지 않는다**는 것입니다.

아키텍처의 핵심 속성으로 성능, 확장성, 단순성, 변경 용이성, 가시성, 이식성, 신뢰성 7가지의 요소가 품질을 정하는 척도라고 합니다.

## 2.1 Scope

운영체제나 프로토콜이 아니라, 네트워크 위에서 동작하는 애플리케이션 구조에 초점을 맞춘다고 합니다.

분산 시스템처럼 분산을 감추는 방식이 아니라, 네트워크 중심으로 분산을 인지하는 방식에 한정하여 REST를 설계한다고 합니다.

왜냐하면 웹은 분산의 현실적 제약을 무시할 수 없기 때문입니다.

REST는 비트 그 자체를 전송하는 네트워크 프로토콜이 아니라, 사용자의 행동을 네트워크 상에서 표현하는 최적의 구조를 제공하는 데에서 시작한다고 합니다.

로이 필딩은 추가로, 웹은 네트워크 위의 애플리케이션이라고 규정합니다.

여기서 REST는 HTTP 위에서 동작하는 애플리케이션 아키텍처 스타일임을 명확히 합니다.

즉, REST는 **어떻게 리소스를 주고받을 것인가**를 정의한 것입니다.

## 2.2 Evaluating the Design of Application Architectures

이 절은 좋은 아키텍처 디자인을 평가하는 법에 대해서 다룹니다.

결론부터 말하자면, 시스템의 아키텍처를 비교하는 것 자체는 불가능하다고 주장합니다.

아키텍처 자체가 런타임을 가정한 동적 구조이기 때문에, 각 환경에 따라 달라지므로 가중치를 부여하여 점수를 매기거나 객관적인 방식으로 평가하기 힘들다는 것입니다.

그렇기 때문에 모든 정보를 한눈에 파악할 수 있는 형태를 제시하고 설계자의 직관(intuition)에 의존하는 것이 낫다고 말합니다.

그러나 좋은 아키텍처인지 아닌지는 판단할 수 있는데, 앞서 언급한 제약과 여기서부터 파생되는 기능적 요구사항과 비기능적 요구사항을 이해하는 것이 중요하다고 강조합니다.

트레이드오프 인식이라는 개념을 제시하였는데, 간단히 말하면 좋은 설계는 모든 속성을 모두 좋게 할 수 없다는 논지입니다.

예를 들어, 캐싱 시스템을 도입하게 되면 효율성은 올라가나 데이터의 최신성이 떨어지는 문제가 발생하는 등, 이런 제약 간 상충을 인지하고 어떤 속성을 우선시할지 결정하는 것이 바로 아키텍트가 해야 할 일이라고 말합니다.

## 2.3 Architectural Properties of Key Interest

이 절에서는 아키텍처 스타일을 구분하고 평가할 때 중요한 속성들을 설명합니다.

즉, 아키텍처의 핵심 지표들에 대해서 설명합니다.

  - Performance: 효율적인 데이터 전송
  - Scalability: 사용자 증가 대응
  - Simplicity: 이해와 검증 용이성
  - Modifiability: 변화에 유연
  - Visibility: 상호작용 추적 가능
  - Portability: 환경 독립성
  - Reliability: 부분 실패 허용

이러한 지표들을 결정하는 핵심은 제약이라고 말합니다.

### 2.3.1 Performance

성능에는 요구사항, 통신 스타일, 설계 구조, 컴포넌트 내부 구현

이렇게 4가지가 영향을 미칩니다.

아무리 코드를 잘 짜더라도, 잘못된 아키텍처를 선택하면 성능의 한계는 명확합니다.

네트워크 성능 요소로 Throughput(처리량), Overhead(부가 비용), Bandwidth(대역폭), Usable Bandwidth(실효 대역폭) 4가지가 있습니다.

사용자 체감 성능은 사용자가 얼마나 빨리 반응을 느끼는가를 나타내는 척도로 Latency(첫 반응까지 걸리는 시간), Completion Time(전체 작업 완료 시간)이 주요 지표로 사용됩니다.

Latency는 다시 5개의 영역에서 발생하는데, 이벤트 감지 시간, 컴포넌트 간 연결 설정, 요청 전송, 응답 처리, 결과 렌더링이 그 영역들입니다.

네트워크를 가장 효율적으로 사용하는 방법은 네트워크를 쓰지 않는 방법이라고 로이 필딩은 주장합니다.

즉, 불필요한 네트워킹 요청을 최소화하는 것이 좋은 아키텍처 스타일입니다.

이를 위해서, 캐싱(과거 응답 재활용), 데이터 복제, 오프라인 모드, 데이터 근처에서 처리하는 모바일 코드가 존재합니다.

REST가 캐시 가능성을 둔 이유도 여기에 있습니다.

### 2.3.2 Scalability

확장성은 더 많은 컴포넌트와 상호작용을 처리할 수 있는 능력을 뜻합니다.

컴포넌트를 단순화하고, 서비스를 분산하며, 모니터링을 통한 동적 개입을 통해 개선할 수 있습니다.

확장성으로 상호작용 빈도, 부하 패턴(균등/피크), 신뢰 수준(controlled/anarchic), 통신 방식(sync/async)에 영향을 미칠 수 있습니다.

**REST의 stateless 제약이 확장성을 극대화하기 위해 선택되었습니다.**

### 2.3.3 Simplicity

단순성은 관심사를 분리하여 나옵니다.

단순성이 높으면 이해하기 쉽고, 구현과 검증이 쉬우며, 유지보수성이 올라갑니다.

단일한 규칙으로 구성된 아키텍처가 가장 단순하고 강력하다는 원칙 하에 REST의 **Uniform Interface** 제약의 근거가 성립되었습니다.

### 2.3.4 Modifiability

소프트웨어는 시간에 따라 변하며, 아키텍처는 변경에 강해야 한다는 철학 아래 생긴 속성입니다.

기능 추가에 유연하고, 변경 시에 영향이 적으며, 일시적으로 특정 동작을 클라이언트가 오버라이드 가능하며, 배포 후에도 구성 요소 변경이 가능하고, 다른 앱에서도 변경없이 사용이 가능하다는 것이 세부 속성입니다.

REST의 "Self-descriptive Message"+"Stateless"는 서로 다른 컴포넌트가 공존해도 충돌하지 않게 합니다.

### 2.3.5 Visibility

가시성은 누가 어떤 상호작용을 보고 중재할 수 있는지에 대한 정도를 나타내는 척도입니다.

가시성이 높으면, 모니터링이 강화되고, 중간 계층(Proxy, Firewall, Gateway) 추가에 용이합니다.

### 2.3.6 Portability

이 속성은 코드가 어디서든 돌아갈 수 있는지를 나타내는 속성입니다.

즉, 코드의 유연성에 대한 속성입니다.

이식성을 다루는 두 가지 방법이 있는데, 하나는 코드가 데이터를 따라 이동하는 구조(가상 머신, Javascript같은 모바일 코드)와 데이터 자체를 옮기는 방식(JSON, MIME, XML 등)이 있습니다.

REST는 후자의 데이터를 옮기는 방식을 택하였습니다.

즉, 표준화된 데이터 표현(Representation)으로 이식성을 보장하였습니다.

### 2.3.7 Reliability

시스템 일부가 실패해도 전체가 멈추지 않는, 병렬성에 대한 척도를 나타낸 속성입니다.

단일 실패 지점 제거, 중복성 확보, 모니터링, 복구 가능한 단위로 실패 범위 제한 등을 통해 확보할 수 있습니다.

REST는 stateless 제약으로 일부 요청이 실패해도 전체 시스템이 멈추지 않습니다.
