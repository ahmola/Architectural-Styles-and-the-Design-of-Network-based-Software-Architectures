# 이론과 현실, 흐름 그리고 고찰

이 문서는 논문 발표 당시(2000)에 필딩이 주장한 것과 현재의 괴리에 대한 고찰을 담았습니다.

## 필딩의 문제인식

필딩은 기본적으로 웹이 API를 전부 다 몰라도 링크를 타고 자연스럽게 흘러가는 구조를 이상적으로 바라봤습니다. 

    {
      "user": { "id": 1, "name": "john" },
      "_links": {
        "self": { "href": "/users/1" },
        "posts": { "href": "/users/1/posts" }
      }
    }

즉, 이런 식으로 "_links"로부터 얻은 url을 통해 하이퍼링크로 **직접**이동하는 방식으로 웹을 바라봤기 때문입니다.

그러나 현대 웹에서는 사람이 직접 모든 링크를 조작하는게 아니라 클라이언트가 모든 걸 대신 처리해주는 **서버-서버**의 구조로 진화하였습니다.

그러니까, 하이퍼미디어를 통한 이동이 필요가 없어진 것입니다.

또한 Stateless가 핵심 전제이기에, 모든 요청에 인증 정보(사용자 로그인 정보 등)이 포함되어야 했는데, 이걸 위해서는 결국 세션 관리가 필수적이었습니다.

그래서 초기에는 이러한 이상과 현실의 타협으로 나온 구조가 세션+쿠키의 구조였습니다.

필딩은 stateless라는 전제에 정면으로 위배되는 쿠키를 싫어했습니다.

6장에서 정보은닉, 서버 확장성, 캐시 효용을 깨뜨린다는 이유에서였습니다.

이후, 현대에는 JWT같은 토큰 형태로 진화하였습니다.

이유는 현대의 웹이 즉각적인 반응(Redis나 Gateway 등과 상태 공유)를 중시하는 방향으로 진화하였기 때문입니다.

즉, 웹이 느리고 지속적인게 아니라 **빠르고 즉각적인** 방향으로 진화해서였습니다.

## 왜 틀린 방향으로 갔나?

일단 들어가기 전에, 상태(State)에 대해 간단하게 짚고 넘어갑시다.

    상태 = 현재 어디서 무엇을 하고 다음에는 무엇을 할 수 있는지

    - 시스템 상태: 서버, 프로세스, 네트워크 등의 현재 정보
    - 애플리케이션 상태: 사용자가 사용 중인 앱의 현재 정보 또는 맥락(로그인 여부, 현재 페이지, 머문 시간 등)
    - 리소스 상태: 저장된 데이터의 현재 값
    
    대부분의 특별한 말이 없다면 애플리케이션의 상태를 말합니다.

사실 이건 이유가 아주 명확했습니다.

React와 Single Page Application 패러다임이 등장하였기 때문입니다.

필딩은 정적 하이퍼미디어 웹을 이상화한 모델을 전제로 REST를 설계하였습니다.

웹 하나 당 상태 하나였던 시대였기에 때문이었습니다.

Facebook에서 React를 발표하면서 웹은 완전히 다른 방향으로 진화하게 되었습니다.

React는 UI 렌더링을 누가 할 것인지와 상태 관리의 위치였습니다.


    클라이언트가 UI를 렌더링하고, 
    상태가 달라지면 가상 DOM이 렌더링해주고, 
    서버 응답을 HTML이 아닌 JSON으로 받고, 
    하이퍼미디어가 아닌 JS코드로 받으며
    프레임워크가 상태를 제어

하는 방식으로 완전히 바뀌게 됩니다.

상태를 완전히 서버가 관리하게 된 것입니다.

이는 사실상 엄청난 충격이었습니다. 왜냐면 HTML문서를 한 번만 받고 상태 전이는 JS코드를 통해서 클라이언트가 Router로 직접 제어하는 방식으로 바뀌었습니다.

즉, 한 번에 하이퍼미디어가 쓸모없어지게 된 것입니다.

클라이언트가 모든 상태를 관리하게 되면서 거대해지는 Stateful SPA 모델이 등장하게 된 것입니다.

서버는 stateless지만 클라이언트는 stateful하게 바뀌게 된 것입니다.

또한, React에서는 HTML을 한번만 받고 JS코드에서 JSON을 통해 표현(Representation)을 받게 되었습니다.

서버가 뷰 렌더링(Thymeleaf, JSP 등)하는 방식이 아니라 클라이언트가 뷰 렌더링하는 방식으로 바뀌게 되었습니다.

REST가 뷰를 생성하기 때문에, 사람이 Representation을 소비하는게 아니라, JS코드가 소비하는 주체로 바뀌게 됩니다.

덕분에, 서버가 클라이언트 상태를 주도하는게 아니라 클라이언트가 필요한 데이터만을 명시적으로 요청하거나(GraphQL), BFF(Backend-For-Frontend)로 API를 따로 관리하게 되었습니다.

즉, 기존의 서버 중심의 REST가 클라이언트 주도로 바뀌게 되었습니다.

## 변천사

필딩의 논문이 발표된 직후 불과 10년뒤에 엄청난 변화가 일어나기 시작했습니다.

2010년부터 **AJAX와 jquery의 등장**으로 JSON을 중심으로 웹이 렌더링되면서 **데이터 중심**의 RESTful API 시대가 열리게 되었습니다.

이 때부터, 프론트엔드와 백엔드의 완전한 분리가 생겨났고 필딩의 HATEOAS는 사실상 사장되었습니다.

2015년에는 **Facebook에서 React**가 탄생하게 됩니다.

클라이언트가 애플리케이션, 그러니까 시스템 전체를 삼켜버리게 됩니다.

UI 렌더링을 클라이언트가 주도하게 되고, 기존의 선택이던 Code-on-Demand는 필수가 되어 HTML은 한 번만 받는 대신 JS로 모든 UI를 조작하게 됩니다.

서버가 상태 전이하는게 아니라 클라이언트가 시스템의 상태를 스스로 제어하도록 바뀌게 된 것입니다.

2018년부터는 **GraphQL과 MSA, AWS 등의 기술이 등장**하였습니다.
  
    클라이언트는 필요한 데이터만 쿼리하게 되었고(GraphQL), 
    서버는 단일 REST 아키텍처가 아닌 여러 서비스로 쪼개지며(MicroService Architecture),
    단일 인터페이스에서 명세 기반 질의

라는 변화를 겪게 됩니다.

REST에서 말한 단일 인터페이스로는 모바일, IoT, 웹 등의 여러 생태계와 플랫폼이 공존하는 현대의 시스템에서는 방대한 데이터를 감당하지 못하는 현상이 발생하게 되었기 때문입니다.

2023년부터는 **이벤트 중심, 스트리밍 중심으로 웹이 하나의 네트워크로** 존재하게 됩니다.

전통적인 REST 아키텍처를 따르는 서버 대신, Edge 컴퓨팅과 Lambda함수가 응답하며 상태는 클라우드 전역에서 계속해서 바뀌는 형식으로 존재하게 됩니다.

이제는 client-server라는 구분조차 사라지게 된 것입니다.

    클라이언트(웹 브라우저, IoT 등) -> Edge Layer(CloudFlare, Fly.io 등) -> Core Cloud/Origin Server(AWS, GCP, Kubernetes 등) -> Data Storage(DB 등)

단일 데이터센터로 가면서 성능이 급격하게 저하되자 사용자와 가까운 서버에서 처리하자는 발상이 생겼고,

이런 구조로 진화하게 되어 클라이언트는 물리적으로 가까운 edge서버에서 클라우드의 서비스를 대신 빠르게 처리해주게 되었습니다.

기존 CDN(Content Delivery Network)가 정적 컨텐츠만을 캐싱하여 제공하였다면, Edge는 코드를 대신 실행해서 동적으로 즉시 처리하는 작업을 맡게 되었습니다.

상태는 네트워크의 edge에 존재하고 API의 집합이 아닌 분산된 상태로 떠돌아다니는 형태로 바뀌게 된 것입니다.

즉, 요청을 최대한 가까운 곳에서 빠르게 처리하고 핵심 비즈니스 로직을 중앙에서 처리하는 구조로 바뀌게 되었습니다.

## 그럼에도 필딩의 논문이 가치가 있는 이유

그럼에도 저는 이 논문이 20년이 지난 현재에도 큰 가치가 있다고 봅니다.

REST는 필딩이 계속해서 강조하듯이 기술이 아니라 **설계 철학**입니다.

또한 필딩의 논문에는 HTTP Method(GET/POST/PUT/DELETE)는 언급조차 되지 않습니다.

왜냐하면 이건 기술 논문이 아니라 방향성을 제시한 **철학**이기 때문이죠.

필딩이 강조한건 Uniform Interface, 어디서나 동일한 표준 인터페이스를 강조한 거였습니다.

즉, **HTTP Method는 REST의 구현체이지 REST 그 자체가 아니라는 것**입니다.

그리고 현재, 필딩이 굉장히 경계했던 **Desing-by-buzzword**, 유행따라 만들기가 현실화 되었죠.

단순히 클라우드 네이티브와 AI 코딩이 유행한다는 흐름이 현재 업계의 흐름인데 이건 정확히 20년전 필딩이 경고했던 현상이었습니다.

필딩은 건축학과 소프트웨어공학의 공통점을 발견하고 건축학의 철학을 소프트웨어공학에 적용시킨 것이였습니다.

필딩은 건축학자 Christopher Alexander에서 큰 영감을 받았습니다.

    좋은 건축은 아름다운 건물이 아니라 건물에 내재된 패턴의 조화이다.

이 말은 곧, 품질은 복잡함과 심미성이 아니라 패턴의 관계와 일관성에서 나온다는 의미였습니다.

그러니까, 건물은 실제 직접 상호작용하는 사용자의 행동 패턴에서 나와야 하듯, 소프트웨어의 형태는 실제로 직접 상호작용하는 네트워크 제약에서 나와야 한다고 말한 것이었습니다.

이러한 철학은 실제로 디자인 패턴을 창시한 GoF 멤버들에게 영감을 주었고, 필딩 또한 REST 아키텍처 스타일을 창안하는데 영감을 받게 되었습니다.

알렉산더가 말한 "시간이 지나도 살아있는 구조"는 필딩의 "진화 가능한 시스템"으로 이어졌습니다.

즉, 필딩은 소프트웨어를 기술이 아닌 건축으로 보았던 것이었고, 그렇기 때문에 기술 유행을 따라가는 것이 아니라 요구사항에 맞게 제약을 설정하는 것을 강조하였습니다.

그럼에도 현재 현실은 필딩이 경고를 무시하고 정반대로 향해 달리고 있습니다.

기술의 황금기에 진입했지만 근본적인 이해보다는 도구 선택 능력이 실력이 되어버린 것이죠.

필딩은 기술이 추상화되면 원리를 잊게 되고, 원리를 잊으면 시스템은 진화하지 못하는 죽는 상태가 된다고 경고했습니다.

필딩은 기술이 아닌, **제약과 형태(패턴)의 조화**였습니다.

철학없이 기술은 지속될 수 없다는 건 비단 소프트웨어분야에서만 한정된 경고가 아니였습니다.

필딩이 논문에서 언급했듯이, 이건 건축학에서 수백년동안 시행착오를 거치면서 얻어낸 귀중한 교훈을 지키지 못해지고 있다고 경고했습니다.

사실 이러한 문제점은 건축학에서 이미 겪었던 부분이기도 합니다.

20세기 모더니즘과 기술의 발전으로 도시를 빠르게 세우는 데에만 집중하였습니다.

그 결과, 도시는 동선의 비효율, 유지보수 불가능한 건물, 열/통풍/일조권의 문제, 구조적 결함으로 인한 잠재적 위험, 치안 불안정까지 이어졌습니다.

기술 낙관주의와 철학의 부재가 가져온 결과였습니다.

건축계는 처음부터 유지보수를 고려한 설계를 해야 지속가능하다는 교훈을 값비싼 사회적 비용을 치르면서 얻게 되었습니다.

즉, 건축물은 일회용품이 아니라 유지되는 생태계라는 깨달음이 맥락 중심의 설계로 이어지게 된 것이었습니다.

오늘날의 소프트웨어업계도 똑같은 위치에 와있는 것처럼 보입니다.

특히나 디지털화와 AI자동화, 저출산과 다문화 사회로 진입하는 대한민국에게 있어서 이러한 소프트웨어업계의 "빨리빨리" 문화에 대해 의문을 던져볼 필요가 있다고 느껴집니다.

우리 사회는 앞으로 더욱 더 많은 부분을 소프트웨어에 의존하게 될 것이고, 이를 기존의 전혀 다른 사회구성원들과 함께 유지보수해야하는 과제를 미래에 직면하게 될 것입니다.

기술적 부채가 누적되고 아무도 시스템을 이해하지 못하는 상태에서 적은 인원으로 서로 다른 배경을 가진 사람들이 사회를 유지하기 위해서는 지금부터 변화가 필요해보입니다.

확실한 건, 미래의 대한민국은 소프트웨어 분야만봐도 지금 밀레니얼 이상의 세대들이 유지하던 방식으로는 절대 유지하거나 발전할 수 없다는 것입니다.

그렇기 때문에, 현재 업계의 문제점을 인식하고 철학적 깊이를 더해가는데 있어서 이 논문은 읽을 충분한 가치가 있다고 생각합니다.
